{"version":3,"file":"things-scene-table.js","sources":["../src/table-cell.js","../src/table.js"],"sourcesContent":["/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport { Component, Container, RectPath, Layout } from '@hatiolab/things-scene'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'editor-table',\n      label: '',\n      name: '',\n      property: {\n        merge: true,\n        split: true\n      }\n    },\n    {\n      type: 'string',\n      label: 'data-key',\n      name: 'dataKey',\n      property: 'dataKey'\n    },\n    {\n      type: 'number',\n      label: 'data-index',\n      name: 'dataIndex',\n      property: 'dataIndex'\n    }\n  ]\n}\n\nconst EMPTY_BORDER = {}\n\nfunction isBottomMost(idx, rows, columns) {\n  return idx >= (rows - 1) * columns\n}\n\nfunction isRightMost(idx, rows, columns) {\n  return (idx + 1) % columns == 0\n}\n\n/**\n * 1. 스타일을 상속 받아야 함. (cascade-style)\n * 2. 스타일을 동적처리할 수 있음. (로직처리)\n * 3. 데이타를 받을 수 있음.\n */\nexport default class TableCell extends RectPath(Component) {\n  // export default class TableCell extends Container {\n\n  // get layout() {\n  //   return Layout.get(this.get('layout') || 'card')\n  // }\n\n  get nature() {\n    return NATURE\n  }\n\n  set merged(merged) {\n    this.set('merged', !!merged)\n    if (merged) this.set('text', '')\n  }\n\n  get merged() {\n    return this.get('merged')\n  }\n\n  set rowspan(rowspan) {\n    this.set('rowspan', rowspan)\n  }\n\n  get rowspan() {\n    return this.get('rowspan')\n  }\n\n  set colspan(colspan) {\n    this.set('colspan', colspan)\n  }\n\n  get colspan() {\n    return this.get('colspan')\n  }\n\n  get border() {\n    var border = this.model.border || EMPTY_BORDER\n  }\n\n  _drawBorder(context, x, y, to_x, to_y, style) {\n    if (style && style.strokeStyle && style.lineWidth && style.lineDash) {\n      context.beginPath()\n      context.moveTo(x, y)\n      context.lineTo(to_x, to_y)\n      Component.drawStroke(context, style)\n    }\n  }\n\n  _draw(context) {\n    var { left, top, width, height } = this.model\n\n    var border = this.model.border || {}\n\n    // Cell 채우기.\n    context.beginPath()\n    context.lineWidth = 0\n    context.rect(left, top, width, height)\n    this.drawFill(context)\n\n    // Border 그리기\n    var parent = this.parent\n    var idx = parent.components.indexOf(this)\n    var columns = parent.columns || 1\n    var rows = parent.rows || 1\n\n    this._drawBorder(context, left, top, left + width, top, border.top)\n    this._drawBorder(context, left, top + height, left, top, border.left)\n    if (isRightMost(idx, rows, columns))\n      this._drawBorder(context, left + width, top, left + width, top + height, border.right)\n    if (isBottomMost(idx, rows, columns))\n      this._drawBorder(context, left + width, top + height, left, top + height, border.bottom)\n  }\n\n  // get capturable() {\n  //   return super.capturable && !this.merged\n  // }\n\n  // _post_draw(context) {\n  //\n  //   this.drawFill(context);\n  //\n  //   /* 자식 컴포넌트들 그리기 */\n  //   var { top, left, scale } = this.model;\n  //   context.translate(left, top);\n  //\n  //   this.layout.drawables(this).forEach(m => {\n  //     m.draw(context);\n  //   });\n  //\n  //   context.translate(-left, -top);\n  //\n  //   this.drawText(context);\n  // }\n}\n\n;['border'].forEach(getter => Component.memoize(TableCell.prototype, getter, false))\n\nComponent.register('table-cell', TableCell)\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport TableCell from './table-cell'\n\nimport { Component, Container, Layout, Model } from '@hatiolab/things-scene'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'number',\n      label: 'rows',\n      name: 'rows',\n      property: 'rows'\n    },\n    {\n      type: 'number',\n      label: 'columns',\n      name: 'columns',\n      property: 'columns'\n    },\n    {\n      type: 'select',\n      label: 'data-spread-to',\n      name: 'spreadTo',\n      property: {\n        options: ['text', 'data']\n      }\n    }\n  ]\n}\n\nconst SIDES = {\n  all: ['top', 'left', 'bottom', 'right'],\n  out: ['top', 'left', 'bottom', 'right'],\n  left: ['left'],\n  right: ['right'],\n  top: ['top'],\n  bottom: ['bottom'],\n  leftright: ['left', 'right'],\n  topbottom: ['top', 'bottom']\n}\n\nconst CLEAR_STYLE = {\n  strokeStyle: '',\n  lineDash: 'solid',\n  lineWidth: 0\n}\n\nconst DEFAULT_STYLE = {\n  strokeStyle: '#999',\n  lineDash: 'solid',\n  lineWidth: 1\n}\n\nconst TABLE_LAYOUT = Layout.get('table')\n\nfunction hasAnyProperty(o, ...properties) {\n  for (let p in properties) {\n    if (o.hasOwnProperty(properties[p])) return true\n  }\n}\n\nfunction buildNewCell(app) {\n  return Model.compile(\n    {\n      type: 'table-cell',\n      strokeStyle: 'blue',\n      left: 0,\n      top: 0,\n      width: 1,\n      height: 1,\n      // fillStyle: 'lightgray',\n      // fillStyle: {\n      //   type: 'pattern',\n      //   image: './images/sample.png',\n      //   fitPattern: true\n      // },\n      textWrap: true,\n      border: buildBorderStyle(DEFAULT_STYLE, 'all')\n    },\n    app\n  )\n}\n\nfunction buildCopiedCell(copy, app) {\n  var obj = JSON.parse(JSON.stringify(copy))\n  delete obj.text\n  return Model.compile(obj, app)\n}\n\nfunction buildBorderStyle(style, where) {\n  return (SIDES[where] || []).reduce((border, side) => {\n    border[side] = style\n    return border\n  }, {})\n}\n\nfunction setCellBorder(cell, style, where) {\n  if (!cell) return\n  cell.set('border', Object.assign({}, cell.get('border') || {}, buildBorderStyle(style, where)))\n}\n\nfunction isLeftMost(total, columns, indices, i) {\n  return i == 0 || !(i % columns) || indices.indexOf(i - 1) == -1\n}\n\nfunction isRightMost(total, columns, indices, i) {\n  return i == total - 1 || i % columns == columns - 1 || indices.indexOf(i + 1) == -1\n}\n\nfunction isTopMost(total, columns, indices, i) {\n  return i < columns || indices.indexOf(i - columns) == -1\n}\n\nfunction isBottomMost(total, columns, indices, i) {\n  return i > total - columns - 1 || indices.indexOf(i + columns) == -1\n}\n\nfunction above(columns, i) {\n  return i - columns\n}\n\nfunction below(columns, i) {\n  return i + columns\n}\n\nfunction before(columns, i) {\n  return !(i % columns) ? -1 : i - 1\n}\n\nfunction after(columns, i) {\n  return !((i + 1) % columns) ? -1 : i + 1\n}\n\nfunction array(value, size) {\n  var arr = []\n  for (let i = 0; i < size; i++) arr.push(1)\n  return arr\n}\n\nvar columnControlHandler = {\n  ondragmove: function(point, index, component) {\n    var { left, top, width, height } = component.textBounds\n    var widths_sum = component.widths_sum\n\n    var widths = component.widths.slice()\n\n    /* 컨트롤의 원래 위치를 구한다. */\n    var origin_pos_unit = widths.slice(0, index + 1).reduce((sum, width) => sum + width, 0)\n    var origin_offset = left + (origin_pos_unit / widths_sum) * width\n\n    /*\n     * point의 좌표는 부모 레이어 기준의 x, y 값이다.\n     * 따라서, 도형의 회전을 감안한 좌표로의 변환이 필요하다.\n     * Transcoord시에는 point좌표가 부모까지 transcoord되어있는 상태이므로,\n     * 컴포넌트자신에 대한 transcoord만 필요하다.(마지막 파라미터를 false로).\n     */\n    var transcoorded = component.transcoordP2S(point.x, point.y)\n    var diff = transcoorded.x - origin_offset\n\n    var diff_unit = (diff / width) * widths_sum\n\n    var min_width_unit = (widths_sum / width) * 10 // 10픽셀정도를 최소로\n\n    if (diff_unit < 0) diff_unit = -Math.min(widths[index] - min_width_unit, -diff_unit)\n    else diff_unit = Math.min(widths[index + 1] - min_width_unit, diff_unit)\n\n    widths[index] = Math.round((widths[index] + diff_unit) * 100) / 100\n    widths[index + 1] = Math.round((widths[index + 1] - diff_unit) * 100) / 100\n\n    component.set('widths', widths)\n  }\n}\n\nvar rowControlHandler = {\n  ondragmove: function(point, index, component) {\n    var { left, top, width, height } = component.textBounds\n    var heights_sum = component.heights_sum\n\n    var heights = component.heights.slice()\n\n    /* 컨트롤의 원래 위치를 구한다. */\n    index -= component.columns - 1\n    var origin_pos_unit = heights.slice(0, index + 1).reduce((sum, height) => sum + height, 0)\n    var origin_offset = top + (origin_pos_unit / heights_sum) * height\n\n    /*\n     * point의 좌표는 부모 레이어 기준의 x, y 값이다.\n     * 따라서, 도형의 회전을 감안한 좌표로의 변환이 필요하다.\n     * Transcoord시에는 point좌표가 부모까지 transcoord되어있는 상태이므로,\n     * 컴포넌트자신에 대한 transcoord만 필요하다.(마지막 파라미터를 false로).\n     */\n    var transcoorded = component.transcoordP2S(point.x, point.y)\n    var diff = transcoorded.y - origin_offset\n\n    var diff_unit = (diff / height) * heights_sum\n\n    var min_height_unit = (heights_sum / height) * 10 // 10픽셀정도를 최소로\n\n    if (diff_unit < 0) diff_unit = -Math.min(heights[index] - min_height_unit, -diff_unit)\n    else diff_unit = Math.min(heights[index + 1] - min_height_unit, diff_unit)\n\n    heights[index] = Math.round((heights[index] + diff_unit) * 100) / 100\n    heights[index + 1] = Math.round((heights[index + 1] - diff_unit) * 100) / 100\n\n    component.set('heights', heights)\n  }\n}\n\nexport default class Table extends Container {\n  created() {\n    var tobeSize = this.rows * this.columns\n    var gap = this.size() - tobeSize\n\n    if (gap == 0) {\n      return\n    } else if (gap > 0) {\n      let removals = this._components.slice(gap)\n      this.remove(removals)\n    } else {\n      let newbies = []\n\n      for (let i = 0; i < -gap; i++) newbies.push(buildNewCell(this.app))\n\n      this.add(newbies)\n    }\n\n    var widths = this.get('widths')\n    var heights = this.get('heights')\n\n    if (!widths || widths.length < this.columns) this.set('widths', this.widths)\n    if (!heights || heights.length < this.rows) this.set('heights', this.heights)\n  }\n\n  // 컴포넌트를 임의로 추가 및 삭제할 수 있는 지를 지정하는 속성임.\n  get focusible() {\n    return false\n  }\n\n  get widths() {\n    var widths = this.get('widths')\n\n    if (!widths) return array(1, this.columns)\n\n    if (widths.length < this.columns) return widths.concat(array(1, this.columns - widths.length))\n    else if (widths.length > this.columns) return widths.slice(0, this.columns)\n\n    return widths\n  }\n\n  get heights() {\n    var heights = this.get('heights')\n\n    if (!heights) return array(1, this.rows)\n\n    if (heights.length < this.rows) return heights.concat(array(1, this.rows - heights.length))\n    else if (heights.length > this.rows) return heights.slice(0, this.rows)\n\n    return heights\n  }\n\n  buildCells(newrows, newcolumns, oldrows, oldcolumns) {\n    if (newrows < oldrows) {\n      let removals = this._components.slice(oldcolumns * newrows)\n\n      // 지우려는 셀중에 병합된 셀을 찾는다.\n      let mergedCells = []\n      removals.forEach(cell => {\n        if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n      })\n\n      // 병합된 셀 중에서 슈퍼셀을 찾는다.\n      if (mergedCells.length > 0) {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.components.indexOf(cell) % oldcolumns\n          row = Math.floor(this.components.indexOf(cell) / oldcolumns)\n          index = row * oldcolumns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.components.indexOf(component) % oldcolumns\n              let spColEnd = (this.components.indexOf(component) % oldcolumns) + component.colspan\n              let spRowStart = Math.floor(this.components.indexOf(component) / oldcolumns)\n              let spRowEnd = Math.floor(this.components.indexOf(component) / oldcolumns) + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        // 슈퍼셀에서 colspan 을 감소시킨다\n        superCells.forEach(cell => {\n          // newcolumns < oldcolumns 케이스와 이 부분만 다름\n          cell.rowspan -= oldrows - newrows\n        })\n      }\n\n      this.remove(removals)\n    }\n\n    var minrows = Math.min(newrows, oldrows)\n\n    if (newcolumns > oldcolumns) {\n      for (let r = 0; r < minrows; r++) {\n        for (let c = oldcolumns; c < newcolumns; c++) {\n          this.insertComponentAt(buildNewCell(this.app), r * newcolumns + c)\n        }\n      }\n    } else if (newcolumns < oldcolumns) {\n      let removals = []\n\n      for (let r = 0; r < minrows; r++) {\n        for (let c = newcolumns; c < oldcolumns; c++) {\n          removals.push(this.components[r * oldcolumns + c])\n        }\n      }\n      // 지우려는 셀중에 병합된 셀을 찾는다.\n      let mergedCells = []\n      removals.forEach(cell => {\n        if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n      })\n\n      // 병합된 셀 중에서 슈퍼셀을 찾는다.\n      if (mergedCells.length > 0) {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.components.indexOf(cell) % oldcolumns\n          row = Math.floor(this.components.indexOf(cell) / oldcolumns)\n          index = row * oldcolumns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.components.indexOf(component) % oldcolumns\n              let spColEnd = (this.components.indexOf(component) % oldcolumns) + component.colspan\n              let spRowStart = Math.floor(this.components.indexOf(component) / oldcolumns)\n              let spRowEnd = Math.floor(this.components.indexOf(component) / oldcolumns) + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        // 슈퍼셀에서 colspan 을 감소시킨다\n        superCells.forEach(cell => {\n          cell.colspan -= oldcolumns - newcolumns\n        })\n      }\n\n      this.remove(removals)\n    }\n\n    if (newrows > oldrows) {\n      let newbies = []\n\n      for (let r = oldrows; r < newrows; r++) {\n        for (let i = 0; i < newcolumns; i++) {\n          newbies.push(buildNewCell(this.app))\n        }\n      }\n      this.add(newbies)\n    }\n\n    this.set({\n      widths: this.widths,\n      heights: this.heights\n    })\n  }\n\n  get layout() {\n    return TABLE_LAYOUT\n  }\n\n  get rows() {\n    return this.get('rows')\n  }\n\n  setCellsStyle(cells, style, where) {\n    var components = this.components\n    var total = components.length\n    var columns = this.get('columns')\n\n    // 병합된 셀도 포함시킨다.\n    var _cells = []\n    cells.forEach(c => {\n      _cells.push(c)\n      if (c.colspan || c.rowspan) {\n        let col = this.getRowColumn(c).column\n        let row = this.getRowColumn(c).row\n        for (let i = row; i < row + c.rowspan; i++)\n          for (let j = col; j < col + c.colspan; j++)\n            if (i != row || j != col) _cells.push(this.components[i * this.columns + j])\n      }\n    })\n    var indices = _cells.map(cell => components.indexOf(cell))\n    indices.forEach(i => {\n      var cell = components[i]\n\n      switch (where) {\n        case 'all':\n          setCellBorder(cell, style, where)\n\n          if (isLeftMost(total, columns, indices, i)) setCellBorder(components[before(columns, i)], style, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], style, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], style, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], style, 'top')\n          break\n        case 'in':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'out':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'left':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          break\n        case 'right':\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          break\n        case 'center':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          break\n        case 'middle':\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'top':\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          break\n        case 'bottom':\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'clear':\n          setCellBorder(cell, CLEAR_STYLE, 'all')\n\n          if (isLeftMost(total, columns, indices, i))\n            setCellBorder(components[before(columns, i)], CLEAR_STYLE, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], CLEAR_STYLE, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], CLEAR_STYLE, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], CLEAR_STYLE, 'top')\n      }\n    })\n  }\n\n  setCellsData() {\n    var data = this.data\n\n    if (!data) return\n\n    data = this.toObjectArrayValue(data) || []\n\n    var cells = this.components\n\n    var { spreadTo = 'text' } = this.state\n\n    cells.forEach(cell => {\n      var dataKey = cell.model.dataKey\n      var dataIndex = cell.model.dataIndex\n      if (dataKey && dataIndex >= 0) cell[spreadTo] = (data[dataIndex] || {})[dataKey]\n    })\n  }\n\n  getRowColumn(cell) {\n    var idx = this.components.indexOf(cell)\n    var length = this.components.length\n\n    return {\n      column: idx % this.columns,\n      row: Math.floor(idx / this.columns)\n    }\n  }\n\n  getCellsByRow(row) {\n    return this.components.slice(row * this.columns, (row + 1) * this.columns)\n  }\n\n  getCellsByColumn(column) {\n    var cells = []\n    for (var i = 0; i < this.rows; i++) cells.push(this.components[this.columns * i + column])\n\n    return cells\n  }\n\n  // 한 개의 행을 매개변수로 받아서 첫 번째 셀부터 우측으로 이동하면서 병합된 셀이 있는지 검사한다.\n  findMergedCellByX(row) {\n    let mergedCells = []\n    let cell\n    for (let i = 0; i < this.columns; i++) {\n      cell = this.components[row * this.columns + i]\n      if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n    }\n    return mergedCells\n  }\n\n  // 한 개의 열을 매개변수로 받아서 첫 번째 셀부터 아래로 이동하면서 병합된 셀이 있는지 검사한다.\n  findMergedCellByY(column) {\n    let mergedCells = []\n    let cell\n    for (let i = 0; i < this.rows; i++) {\n      cell = this.components[i * this.columns + column]\n      if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n    }\n    return mergedCells\n  }\n\n  mergeCells(cells) {\n    // 선택한 셀이 들어있는 행\n    let mergeableRows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == mergeableRows.indexOf(row)) mergeableRows.push(row)\n    })\n\n    // 선택한 셀의 행이 연속적인 숫자가 아니라면 병합하지 않는다.\n    if (mergeableRows.length - 1 !== mergeableRows[mergeableRows.length - 1] - mergeableRows[0]) return false\n\n    // 선택한 셀이 들어있는 열\n    let mergeableColumns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == mergeableColumns.indexOf(column)) mergeableColumns.push(column)\n    })\n\n    // 선택한 셀의 열이 연속적인 숫자가 아니라면 병합하지 않는다.\n    if (mergeableColumns.length - 1 !== mergeableColumns[mergeableColumns.length - 1] - mergeableColumns[0])\n      return false\n\n    // 병합할 행의 수\n    let numberOfRows = mergeableRows.length\n\n    // 병합할 열의 수\n    let numberOfColumns = mergeableColumns.length\n\n    // 선택된 셀의 수\n    let numberOfCells = cells.length\n\n    // 병합될 조건 검사\n    // 행과 열의 곱이 셀의 수가 아니거나 셀의 수가 2보다 작은 경우는 병합하지 않는다.\n    if (numberOfCells !== numberOfRows * numberOfColumns || numberOfCells < 2) return false\n\n    // 선택한 셀들을 index 값이 낮은 것부터 순서대로 재정렬\n    cells.sort((a, b) => {\n      return (\n        this.getRowColumn(a).row * this.columns +\n        this.getRowColumn(a).column -\n        (this.getRowColumn(b).row * this.columns + this.getRowColumn(b).column)\n      )\n    })\n\n    // 셀을 병합함\n    let firstCell = cells[0]\n    firstCell.set({\n      colspan: numberOfColumns,\n      rowspan: numberOfRows\n    })\n\n    // 첫 번째 셀을 제외한 나머지 셀을 true로 지정\n    for (let i = 1; i < numberOfCells; i++) cells[i].merged = true\n\n    // 병합 후에는 첫 번째 셀을 선택하도록 함\n    this.root.selected = [firstCell]\n  }\n\n  splitCells(cells) {\n    // 선택한 병합된 셀의 정보를 가져온다.\n    let firstCellRowColumn = this.getRowColumn(cells[0])\n    let firstCell = cells[0]\n    let firstCellIndex = this.components.indexOf(cells[0])\n    let length = this.components.length\n    let lastCell = this.components[length - 1]\n    let lastCellRowColumn = this.getRowColumn(lastCell)\n    let startIndex = length / (lastCellRowColumn.row + 1)\n\n    // 병합된 셀들을 구해서 merged를 false로 설정한다.\n    // 자식 셀이 갖고 있는 부모 셀의 위치를 초기화 한다.\n    for (let j = 0; j < firstCell.rowspan; j++) {\n      let index\n      let nextCell\n      for (let i = firstCellIndex; i < firstCellIndex + firstCell.colspan; i++) {\n        index = startIndex * j + i\n        nextCell = this.components[index]\n        nextCell.merged = false\n      }\n    }\n\n    // 첫 번째 셀의 rowspan, colspan = 1로 지정한다.\n    firstCell.colspan = 1\n    firstCell.rowspan = 1\n  }\n\n  deleteRows(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    var heights = this.heights.slice()\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 지운다.\n      if (mergedCells.length === 0) {\n        this.remove(this.getCellsByRow(row))\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 지워야 한다.\n      //\n      else {\n        // 삭제할 행에서 병합된 셀을 삭제할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          let superCellRow = Math.floor(index / this.columns)\n          // 지우려는 행이 슈퍼셀을 포함한 경우이면서 슈퍼셀이 마지막 행의 셀이 아닌 경우\n          // 그리고 슈퍼셀의 rowspan이 1보다 큰 경우\n          if (row === superCellRow && superCellRow !== this.rows - 1 && this.components[index].rowspan > 1) {\n            this.components[index + this.columns].rowspan = this.components[index].rowspan - 1\n            this.components[index + this.columns].colspan = this.components[index].colspan\n            this.components[index + this.columns].merged = false\n            this.components[index + this.columns].set('text', this.components[index].get('text'))\n          } else {\n            this.components[index].rowspan -= 1\n          }\n        })\n        this.remove(this.getCellsByRow(row))\n      }\n    })\n    heights.splice(rows, 1)\n    this.model.rows -= rows.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n    this.set('heights', heights)\n  }\n\n  deleteColumns(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n\n    columns.forEach(column => {\n      var widths = this.widths.slice()\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 지운다.\n      if (mergedCells.length === 0) {\n        this.remove(this.getCellsByColumn(column))\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 지워야 한다.\n      else {\n        // 삭제할 열에서 병합된 셀을 삭제할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          let superCellColumn = index % this.columns\n          // 지우려는 열이 슈퍼셀을 포함한 경우이면서 슈퍼셀이 마지막 열의 셀이 아닌 경우\n          // 그리고 슈퍼셀의 colspan이 1보다 큰 경우\n          if (\n            column === superCellColumn &&\n            superCellColumn !== this.columns - 1 &&\n            this.components[index].colspan > 1\n          ) {\n            this.components[index + 1].rowspan = this.components[index].rowspan\n            this.components[index + 1].colspan = this.components[index].colspan - 1\n            this.components[index + 1].merged = false\n            this.components[index + 1].set('text', this.components[index].get('text'))\n          } else {\n            this.components[index].colspan -= 1\n          }\n        })\n        this.remove(this.getCellsByColumn(column))\n      }\n      widths.splice(column, 1)\n      this.model.columns -= 1 // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n      this.set('widths', widths)\n    })\n  }\n\n  insertCellsAbove(cells) {\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    // 행 2개 이상은 추가 안함. 임시로 막아놓음\n    if (rows.length >= 2) return false\n    let insertionRowPosition = rows[0]\n    let newbieRowHeights = []\n    let newbieCells = []\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 위에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.columns; i++)\n          newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n        newbieRowHeights.push(this.heights[row])\n\n        newbieCells.reverse().forEach(cell => {\n          this.insertComponentAt(cell, insertionRowPosition * this.columns)\n        })\n\n        let heights = this.heights.slice()\n        heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n        this.set('heights', heights)\n\n        this.model.rows += rows.length\n\n        this.clearCache()\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 추가해야 한다.\n      else {\n        // 선택한 행이 2개 이상 있고 그 중에 병합된 셀이 적어도 한 개라도 있으면\n        // 병합된 셀이 포함된 행의 추가는 무시한다. 임시방편으로 막아놈\n        if (rows.length > 1) return false\n        // 추가할 행에서 병합된 셀을 추가할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 행이 슈퍼셀을 포함한 경우\n          if (superCellRow === row) {\n            for (let i = 0; i < this.columns; i++) newbieCells.push(buildNewCell(this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index + this.columns].rowspan = superCellObj.rowspan\n            this.components[index + this.columns].colspan = superCellObj.colspan\n            this.components[index + this.columns].set('text', superCellObj.text)\n            this.components[index + this.columns].merged = superCellObj.merged\n          } else {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n          }\n          let heights = this.heights.slice()\n          heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n          this.set('heights', heights)\n\n          this.model.rows += rows.length\n\n          this.clearCache()\n        })\n      }\n    })\n  }\n\n  insertCellsBelow(cells) {\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    // 행 2개 이상은 추가 안함. 임시로 막아놓음\n    if (rows.length >= 2) return false\n    let insertionRowPosition = rows[rows.length - 1] + 1\n    let newbieRowHeights = []\n    let newbieCells = []\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 아래에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.columns; i++)\n          newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n        newbieRowHeights.push(this.heights[row])\n\n        newbieCells.reverse().forEach(cell => {\n          this.insertComponentAt(cell, insertionRowPosition * this.columns)\n        })\n\n        let heights = this.heights.slice()\n        heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n        this.set('heights', heights)\n\n        this.model.rows += 1\n\n        this.clearCache()\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 추가해야 한다.\n      else {\n        // 추가할 행에서 병합된 셀을 추가할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 행이 병합된 셀중 마지막 행인 경우\n          if (superCellRow + superCellObj.rowspan - 1 === row) {\n            for (let i = 0; i < this.columns; i++) newbieCells.push(buildNewCell(this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n          } else if (superCellRow === row) {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n            // 슈퍼셀이 복사됐으므로 그 해당 셀을 병합된 셀로 설정한다.\n            this.components[index + this.columns].rowspan = 1\n            this.components[index + this.columns].colspan = 1\n            this.components[index + this.columns].merged = true\n            this.components[index + this.columns].set('text', '')\n          } else {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n          }\n          let heights = this.heights.slice()\n          heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n          this.set('heights', heights)\n\n          this.model.rows += 1\n\n          this.clearCache()\n        })\n      }\n    })\n  }\n\n  insertCellsLeft(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[0]\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 왼쪽에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.rows; i++)\n          newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n        newbieColumnWidths.push(this.widths[column])\n\n        let increasedColumns = this.columns\n        let index = this.rows\n        newbieCells.reverse().forEach(cell => {\n          if (index == 0) {\n            index = this.rows\n            increasedColumns++\n          }\n\n          index--\n          this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n        })\n\n        let widths = this.widths.slice()\n        this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n        widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n        this.set('widths', widths)\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 추가해야 한다.\n      else {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellColumn = index % this.columns\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 열이 슈퍼셀을 포함한 경우\n          if (superCellColumn === column) {\n            for (let i = 0; i < this.rows; i++) newbieCells.push(buildNewCell(this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          } else {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          }\n          let widths = this.widths.slice()\n          this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n          widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n          this.set('widths', widths)\n        })\n      }\n    })\n  }\n\n  insertCellsRight(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[columns.length - 1] + 1\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 오른쪽에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.rows; i++)\n          newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n        newbieColumnWidths.push(this.widths[column])\n\n        let increasedColumns = this.columns\n        let index = this.rows\n        newbieCells.reverse().forEach(cell => {\n          if (index == 0) {\n            index = this.rows\n            increasedColumns++\n          }\n\n          index--\n          this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n        })\n\n        let widths = this.widths.slice()\n        this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n        widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n        this.set('widths', widths)\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 추가해야 한다.\n      else {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellColumn = index % this.columns\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 열이 병합된 셀중 마지막 열인 경우\n          if (superCellColumn + superCellObj.colspan - 1 === column) {\n            for (let i = 0; i < this.rows; i++) newbieCells.push(buildNewCell(this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          } else if (superCellColumn === column) {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n            // 슈퍼셀이 복사됐으므로 그 해당 셀을 병합된 셀로 설정한다.\n            this.components[index + superCellRow + 1].rowspan = 1\n            this.components[index + superCellRow + 1].colspan = 1\n            this.components[index + superCellRow + 1].merged = true\n            this.components[index + superCellRow + 1].set('text', '')\n          } else {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          }\n          let widths = this.widths.slice()\n          this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n          widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n          this.set('widths', widths)\n        })\n      }\n    })\n  }\n\n  distributeHorizontal(cells) {\n    var columns = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == columns.indexOf(rowcolumn.column)) columns.push(rowcolumn.column)\n    })\n\n    var sum = columns.reduce((sum, column) => {\n      return sum + this.widths[column]\n    }, 0)\n\n    var newval = Math.round((sum / columns.length) * 100) / 100\n    var widths = this.widths.slice()\n    columns.forEach(column => {\n      widths[column] = newval\n    })\n\n    this.set('widths', widths)\n  }\n\n  distributeVertical(cells) {\n    var rows = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == rows.indexOf(rowcolumn.row)) rows.push(rowcolumn.row)\n    })\n\n    var sum = rows.reduce((sum, row) => {\n      return sum + this.heights[row]\n    }, 0)\n\n    var newval = Math.round((sum / rows.length) * 100) / 100\n    var heights = this.heights.slice()\n    rows.forEach(row => {\n      heights[row] = newval\n    })\n\n    this.set('heights', heights)\n  }\n\n  toObjectArrayValue(array) {\n    if (!array || array.length === 0) return null\n\n    if (!array[0].hasOwnProperty('__field1')) {\n      return array\n    }\n\n    let indexKeyMap = {}\n    let value = []\n\n    for (let key in array[0]) {\n      indexKeyMap[key] = array[0][key]\n    }\n\n    for (var i = 1; i < array.length; i++) {\n      let object = {}\n      let thisObject = array[i]\n      for (let key in indexKeyMap) {\n        let k = indexKeyMap[key]\n        let v = thisObject[key]\n        object[k] = v\n      }\n\n      value.push(object)\n    }\n\n    return value\n  }\n\n  get columns() {\n    return this.get('columns')\n  }\n\n  get lefts() {\n    return this.components.filter((c, i) => {\n      return !(i % this.columns)\n    })\n  }\n\n  get centers() {\n    return this.components.filter((c, i) => {\n      return i % this.columns && (i + 1) % this.columns\n    })\n  }\n\n  get rights() {\n    return this.components.filter((c, i) => {\n      return !((i + 1) % this.columns)\n    })\n  }\n\n  get tops() {\n    return this.components.slice(0, this.columns)\n  }\n\n  get middles() {\n    return this.components.slice(this.columns, this.columns * (this.rows - 1))\n  }\n\n  get bottoms() {\n    return this.components.slice(this.columns * (this.rows - 1))\n  }\n\n  get all() {\n    return this.components\n  }\n\n  get widths_sum() {\n    var widths = this.widths\n    return widths ? widths.filter((width, i) => i < this.columns).reduce((sum, width) => sum + width, 0) : this.columns\n  }\n\n  get heights_sum() {\n    var heights = this.heights\n    return heights ? heights.filter((height, i) => i < this.rows).reduce((sum, height) => sum + height, 0) : this.rows\n  }\n\n  get nature() {\n    return NATURE\n  }\n\n  get controls() {\n    var widths = this.widths\n    var heights = this.heights\n    var inside = this.textBounds\n\n    var width_unit = inside.width / this.widths_sum\n    var height_unit = inside.height / this.heights_sum\n\n    var x = inside.left\n    var y = inside.top\n\n    var controls = []\n\n    widths.slice(0, this.columns - 1).forEach(width => {\n      x += width * width_unit\n      controls.push({\n        x: x,\n        y: inside.top,\n        handler: columnControlHandler\n      })\n    })\n\n    heights.slice(0, this.rows - 1).forEach(height => {\n      y += height * height_unit\n      controls.push({\n        x: inside.left,\n        y: y,\n        handler: rowControlHandler\n      })\n    })\n\n    return controls\n  }\n\n  onchange(after, before) {\n    if (hasAnyProperty(after, 'rows', 'columns')) {\n      this.buildCells(\n        this.get('rows'),\n        this.get('columns'),\n        before.hasOwnProperty('rows') ? before.rows : this.get('rows'),\n        before.hasOwnProperty('columns') ? before.columns : this.get('columns')\n      )\n    }\n\n    if (before.data || after.data) {\n      this.setCellsData()\n    }\n  }\n\n  get eventMap() {\n    return {\n      '(self)': {\n        '(descendant)': {\n          change: this.oncellchanged\n        }\n      }\n    }\n  }\n\n  oncellchanged(after, before) {\n    if (hasAnyProperty(after, 'dataKey', 'dataIndex')) {\n      this.setCellsData()\n    }\n  }\n}\n\n;['rows', 'columns', 'widths', 'heights', 'widths_sum', 'heights_sum', 'controls'].forEach(getter =>\n  Component.memoize(Table.prototype, getter, false)\n)\n\nComponent.register('table', Table)\n"],"names":["NATURE","mutable","resizable","rotatable","properties","type","label","name","property","merge","split","TableCell","RectPath","Component","context","x","y","to_x","to_y","style","strokeStyle","lineWidth","lineDash","beginPath","moveTo","lineTo","drawStroke","this","model","left","top","width","height","border","rect","drawFill","parent","idx","components","indexOf","columns","rows","_drawBorder","isRightMost","right","isBottomMost","bottom","merged","set","get","rowspan","colspan","forEach","getter","memoize","prototype","register","options","SIDES","all","out","leftright","topbottom","CLEAR_STYLE","DEFAULT_STYLE","TABLE_LAYOUT","Layout","hasAnyProperty","o","p","hasOwnProperty","buildNewCell","app","Model","compile","textWrap","buildBorderStyle","buildCopiedCell","copy","obj","JSON","parse","stringify","text","where","reduce","side","setCellBorder","cell","Object","assign","isLeftMost","total","indices","i","isTopMost","above","below","before","after","array","value","size","arr","push","columnControlHandler","ondragmove","point","index","component","textBounds","widths_sum","widths","slice","origin_offset","sum","diff_unit","transcoordP2S","min_width_unit","Math","min","round","rowControlHandler","heights_sum","heights","min_height_unit","Table","Container","tobeSize","gap","removals","_components","remove","newbies","add","length","newrows","newcolumns","oldrows","oldcolumns","mergedCells","superCells","superCellIndexes","col","row","_this","floor","spColStart","spColEnd","spRowStart","spRowEnd","minrows","r","c","insertComponentAt","cells","_cells","_this2","getRowColumn","column","j","map","data","toObjectArrayValue","state","spreadTo","dataKey","dataIndex","mergeableRows","_this3","mergeableColumns","numberOfRows","numberOfColumns","numberOfCells","sort","a","b","firstCell","root","selected","firstCellIndex","lastCell","startIndex","_this4","reverse","findMergedCellByX","getCellsByRow","superCellRow","splice","_this5","findMergedCellByY","getCellsByColumn","superCellColumn","_this6","insertionRowPosition","newbieRowHeights","newbieCells","clearCache","superCellObj","_this7","_this8","insertionColumnPosition","newbieColumnWidths","increasedColumns","rowIndex","_this9","rowcolumn","_this10","newval","_this11","indexKeyMap","key","object","thisObject","k","v","buildCells","setCellsData","concat","filter","_this12","_this13","_this14","_this15","_this16","inside","width_unit","height_unit","controls","handler","change","oncellchanged"],"mappings":"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"}