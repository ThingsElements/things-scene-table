{"version":3,"file":"things-scene-table.js","sources":["../src/table.js","../src/table-cell.js"],"sourcesContent":["/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport { Component, Container, Layout, Model } from '@hatiolab/things-scene'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'number',\n      label: 'rows',\n      name: 'rows',\n      property: 'rows'\n    },\n    {\n      type: 'number',\n      label: 'columns',\n      name: 'columns',\n      property: 'columns'\n    },\n    {\n      type: 'select',\n      label: 'data-spread-to',\n      name: 'spreadTo',\n      property: {\n        options: ['text', 'data']\n      }\n    }\n  ],\n  'value-property': 'data'\n}\n\nconst SIDES = {\n  all: ['top', 'left', 'bottom', 'right'],\n  out: ['top', 'left', 'bottom', 'right'],\n  left: ['left'],\n  right: ['right'],\n  top: ['top'],\n  bottom: ['bottom'],\n  leftright: ['left', 'right'],\n  topbottom: ['top', 'bottom']\n}\n\nconst CLEAR_STYLE = {\n  strokeStyle: '',\n  lineDash: 'solid',\n  lineWidth: 0\n}\n\nconst DEFAULT_STYLE = {\n  strokeStyle: '#999',\n  lineDash: 'solid',\n  lineWidth: 1\n}\n\nconst TABLE_LAYOUT = Layout.get('table')\n\nfunction buildNewCell(app) {\n  return Model.compile(\n    {\n      type: 'table-cell',\n      strokeStyle: 'blue',\n      left: 0,\n      top: 0,\n      width: 1,\n      height: 1,\n      textWrap: true,\n      border: buildBorderStyle(DEFAULT_STYLE, 'all')\n    },\n    app\n  )\n}\n\nfunction buildCopiedCell(copy, app) {\n  var obj = JSON.parse(JSON.stringify(copy))\n  delete obj.text\n  return Model.compile(obj, app)\n}\n\nfunction buildBorderStyle(style, where) {\n  return (SIDES[where] || []).reduce((border, side) => {\n    border[side] = style\n    return border\n  }, {})\n}\n\nfunction setCellBorder(cell, style, where) {\n  if (!cell) return\n  cell.set('border', Object.assign({}, cell.get('border') || {}, buildBorderStyle(style, where)))\n}\n\nfunction isLeftMost(total, columns, indices, i) {\n  return i == 0 || !(i % columns) || indices.indexOf(i - 1) == -1\n}\n\nfunction isRightMost(total, columns, indices, i) {\n  return i == total - 1 || i % columns == columns - 1 || indices.indexOf(i + 1) == -1\n}\n\nfunction isTopMost(total, columns, indices, i) {\n  return i < columns || indices.indexOf(i - columns) == -1\n}\n\nfunction isBottomMost(total, columns, indices, i) {\n  return i > total - columns - 1 || indices.indexOf(i + columns) == -1\n}\n\nfunction above(columns, i) {\n  return i - columns\n}\n\nfunction below(columns, i) {\n  return i + columns\n}\n\nfunction before(columns, i) {\n  return !(i % columns) ? -1 : i - 1\n}\n\nfunction after(columns, i) {\n  return !((i + 1) % columns) ? -1 : i + 1\n}\n\nfunction array(value, size) {\n  var arr = []\n  for (let i = 0; i < size; i++) arr.push(1)\n  return arr\n}\n\nvar columnControlHandler = {\n  ondragmove: function(point, index, component) {\n    var { left, top, width, height } = component.textBounds\n    var widths_sum = component.widths_sum\n\n    var widths = component.widths.slice()\n\n    /* 컨트롤의 원래 위치를 구한다. */\n    var origin_pos_unit = widths.slice(0, index + 1).reduce((sum, width) => sum + width, 0)\n    var origin_offset = left + (origin_pos_unit / widths_sum) * width\n\n    /*\n     * point의 좌표는 부모 레이어 기준의 x, y 값이다.\n     * 따라서, 도형의 회전을 감안한 좌표로의 변환이 필요하다.\n     * Transcoord시에는 point좌표가 부모까지 transcoord되어있는 상태이므로,\n     * 컴포넌트자신에 대한 transcoord만 필요하다.(마지막 파라미터를 false로).\n     */\n    var transcoorded = component.transcoordP2S(point.x, point.y)\n    var diff = transcoorded.x - origin_offset\n\n    var diff_unit = (diff / width) * widths_sum\n\n    var min_width_unit = (widths_sum / width) * 10 // 10픽셀정도를 최소로\n\n    if (diff_unit < 0) diff_unit = -Math.min(widths[index] - min_width_unit, -diff_unit)\n    else diff_unit = Math.min(widths[index + 1] - min_width_unit, diff_unit)\n\n    widths[index] = Math.round((widths[index] + diff_unit) * 100) / 100\n    widths[index + 1] = Math.round((widths[index + 1] - diff_unit) * 100) / 100\n\n    component.set('widths', widths)\n  }\n}\n\nvar rowControlHandler = {\n  ondragmove: function(point, index, component) {\n    var { left, top, width, height } = component.textBounds\n    var heights_sum = component.heights_sum\n\n    var heights = component.heights.slice()\n\n    /* 컨트롤의 원래 위치를 구한다. */\n    index -= component.columns - 1\n    var origin_pos_unit = heights.slice(0, index + 1).reduce((sum, height) => sum + height, 0)\n    var origin_offset = top + (origin_pos_unit / heights_sum) * height\n\n    /*\n     * point의 좌표는 부모 레이어 기준의 x, y 값이다.\n     * 따라서, 도형의 회전을 감안한 좌표로의 변환이 필요하다.\n     * Transcoord시에는 point좌표가 부모까지 transcoord되어있는 상태이므로,\n     * 컴포넌트자신에 대한 transcoord만 필요하다.(마지막 파라미터를 false로).\n     */\n    var transcoorded = component.transcoordP2S(point.x, point.y)\n    var diff = transcoorded.y - origin_offset\n\n    var diff_unit = (diff / height) * heights_sum\n\n    var min_height_unit = (heights_sum / height) * 10 // 10픽셀정도를 최소로\n\n    if (diff_unit < 0) diff_unit = -Math.min(heights[index] - min_height_unit, -diff_unit)\n    else diff_unit = Math.min(heights[index + 1] - min_height_unit, diff_unit)\n\n    heights[index] = Math.round((heights[index] + diff_unit) * 100) / 100\n    heights[index + 1] = Math.round((heights[index + 1] - diff_unit) * 100) / 100\n\n    component.set('heights', heights)\n  }\n}\n\nexport default class Table extends Container {\n  created() {\n    var tobeSize = this.rows * this.columns\n    var gap = this.size() - tobeSize\n\n    if (gap == 0) {\n      return\n    } else if (gap > 0) {\n      let removals = this._components.slice(gap)\n      this.remove(removals)\n    } else {\n      let newbies = []\n\n      for (let i = 0; i < -gap; i++) newbies.push(buildNewCell(this.app))\n\n      this.add(newbies)\n    }\n\n    var widths = this.get('widths')\n    var heights = this.get('heights')\n\n    if (!widths || widths.length < this.columns) this.set('widths', this.widths)\n    if (!heights || heights.length < this.rows) this.set('heights', this.heights)\n  }\n\n  // 컴포넌트를 임의로 추가 및 삭제할 수 있는 지를 지정하는 속성임.\n  get focusible() {\n    return false\n  }\n\n  get widths() {\n    var widths = this.get('widths')\n\n    if (!widths) return array(1, this.columns)\n\n    if (widths.length < this.columns) return widths.concat(array(1, this.columns - widths.length))\n    else if (widths.length > this.columns) return widths.slice(0, this.columns)\n\n    return widths\n  }\n\n  get heights() {\n    var heights = this.get('heights')\n\n    if (!heights) return array(1, this.rows)\n\n    if (heights.length < this.rows) return heights.concat(array(1, this.rows - heights.length))\n    else if (heights.length > this.rows) return heights.slice(0, this.rows)\n\n    return heights\n  }\n\n  buildCells(newrows, newcolumns, oldrows, oldcolumns) {\n    if (newrows < oldrows) {\n      let removals = this._components.slice(oldcolumns * newrows)\n\n      // 지우려는 셀중에 병합된 셀을 찾는다.\n      let mergedCells = []\n      removals.forEach(cell => {\n        if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n      })\n\n      // 병합된 셀 중에서 슈퍼셀을 찾는다.\n      if (mergedCells.length > 0) {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.components.indexOf(cell) % oldcolumns\n          row = Math.floor(this.components.indexOf(cell) / oldcolumns)\n          index = row * oldcolumns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.components.indexOf(component) % oldcolumns\n              let spColEnd = (this.components.indexOf(component) % oldcolumns) + component.colspan\n              let spRowStart = Math.floor(this.components.indexOf(component) / oldcolumns)\n              let spRowEnd = Math.floor(this.components.indexOf(component) / oldcolumns) + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        // 슈퍼셀에서 colspan 을 감소시킨다\n        superCells.forEach(cell => {\n          // newcolumns < oldcolumns 케이스와 이 부분만 다름\n          cell.rowspan -= oldrows - newrows\n        })\n      }\n\n      this.remove(removals)\n    }\n\n    var minrows = Math.min(newrows, oldrows)\n\n    if (newcolumns > oldcolumns) {\n      for (let r = 0; r < minrows; r++) {\n        for (let c = oldcolumns; c < newcolumns; c++) {\n          this.insertComponentAt(buildNewCell(this.app), r * newcolumns + c)\n        }\n      }\n    } else if (newcolumns < oldcolumns) {\n      let removals = []\n\n      for (let r = 0; r < minrows; r++) {\n        for (let c = newcolumns; c < oldcolumns; c++) {\n          removals.push(this.components[r * oldcolumns + c])\n        }\n      }\n      // 지우려는 셀중에 병합된 셀을 찾는다.\n      let mergedCells = []\n      removals.forEach(cell => {\n        if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n      })\n\n      // 병합된 셀 중에서 슈퍼셀을 찾는다.\n      if (mergedCells.length > 0) {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.components.indexOf(cell) % oldcolumns\n          row = Math.floor(this.components.indexOf(cell) / oldcolumns)\n          index = row * oldcolumns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.components.indexOf(component) % oldcolumns\n              let spColEnd = (this.components.indexOf(component) % oldcolumns) + component.colspan\n              let spRowStart = Math.floor(this.components.indexOf(component) / oldcolumns)\n              let spRowEnd = Math.floor(this.components.indexOf(component) / oldcolumns) + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        // 슈퍼셀에서 colspan 을 감소시킨다\n        superCells.forEach(cell => {\n          cell.colspan -= oldcolumns - newcolumns\n        })\n      }\n\n      this.remove(removals)\n    }\n\n    if (newrows > oldrows) {\n      let newbies = []\n\n      for (let r = oldrows; r < newrows; r++) {\n        for (let i = 0; i < newcolumns; i++) {\n          newbies.push(buildNewCell(this.app))\n        }\n      }\n      this.add(newbies)\n    }\n\n    this.set({\n      widths: this.widths,\n      heights: this.heights\n    })\n  }\n\n  get layout() {\n    return TABLE_LAYOUT\n  }\n\n  get rows() {\n    return Number(this.get('rows'))\n  }\n\n  setCellsStyle(cells, style, where) {\n    var components = this.components\n    var total = components.length\n    var columns = this.get('columns')\n\n    // 병합된 셀도 포함시킨다.\n    var _cells = []\n    cells.forEach(c => {\n      _cells.push(c)\n      if (c.colspan || c.rowspan) {\n        let col = this.getRowColumn(c).column\n        let row = this.getRowColumn(c).row\n        for (let i = row; i < row + c.rowspan; i++)\n          for (let j = col; j < col + c.colspan; j++)\n            if (i != row || j != col) _cells.push(this.components[i * this.columns + j])\n      }\n    })\n    var indices = _cells.map(cell => components.indexOf(cell))\n    indices.forEach(i => {\n      var cell = components[i]\n\n      switch (where) {\n        case 'all':\n          setCellBorder(cell, style, where)\n\n          if (isLeftMost(total, columns, indices, i)) setCellBorder(components[before(columns, i)], style, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], style, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], style, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], style, 'top')\n          break\n        case 'in':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'out':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'left':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          break\n        case 'right':\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          break\n        case 'center':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          break\n        case 'middle':\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'top':\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          break\n        case 'bottom':\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'clear':\n          setCellBorder(cell, CLEAR_STYLE, 'all')\n\n          if (isLeftMost(total, columns, indices, i))\n            setCellBorder(components[before(columns, i)], CLEAR_STYLE, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], CLEAR_STYLE, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], CLEAR_STYLE, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], CLEAR_STYLE, 'top')\n      }\n    })\n  }\n\n  setCellsData() {\n    var data = this.data\n\n    if (!data) return\n\n    data = this.toObjectArrayValue(data) || []\n\n    var cells = this.components\n\n    var { spreadTo = 'text' } = this.state\n\n    cells.forEach(cell => {\n      var dataKey = cell.model.dataKey\n      var dataIndex = cell.model.dataIndex\n      if (dataKey && dataIndex >= 0) cell[spreadTo] = (data[dataIndex] || {})[dataKey]\n    })\n  }\n\n  getRowColumn(cell) {\n    var idx = this.components.indexOf(cell)\n    var length = this.components.length\n\n    return {\n      column: idx % this.columns,\n      row: Math.floor(idx / this.columns)\n    }\n  }\n\n  getCellsByRow(row) {\n    return this.components.slice(row * this.columns, (row + 1) * this.columns)\n  }\n\n  getCellsByColumn(column) {\n    var cells = []\n    for (var i = 0; i < this.rows; i++) cells.push(this.components[this.columns * i + column])\n\n    return cells\n  }\n\n  // 한 개의 행을 매개변수로 받아서 첫 번째 셀부터 우측으로 이동하면서 병합된 셀이 있는지 검사한다.\n  findMergedCellByX(row) {\n    let mergedCells = []\n    let cell\n    for (let i = 0; i < this.columns; i++) {\n      cell = this.components[row * this.columns + i]\n      if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n    }\n    return mergedCells\n  }\n\n  // 한 개의 열을 매개변수로 받아서 첫 번째 셀부터 아래로 이동하면서 병합된 셀이 있는지 검사한다.\n  findMergedCellByY(column) {\n    let mergedCells = []\n    let cell\n    for (let i = 0; i < this.rows; i++) {\n      cell = this.components[i * this.columns + column]\n      if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n    }\n    return mergedCells\n  }\n\n  mergeCells(cells) {\n    // 선택한 셀이 들어있는 행\n    let mergeableRows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == mergeableRows.indexOf(row)) mergeableRows.push(row)\n    })\n\n    // 선택한 셀의 행이 연속적인 숫자가 아니라면 병합하지 않는다.\n    if (mergeableRows.length - 1 !== mergeableRows[mergeableRows.length - 1] - mergeableRows[0]) return false\n\n    // 선택한 셀이 들어있는 열\n    let mergeableColumns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == mergeableColumns.indexOf(column)) mergeableColumns.push(column)\n    })\n\n    // 선택한 셀의 열이 연속적인 숫자가 아니라면 병합하지 않는다.\n    if (mergeableColumns.length - 1 !== mergeableColumns[mergeableColumns.length - 1] - mergeableColumns[0])\n      return false\n\n    // 병합할 행의 수\n    let numberOfRows = mergeableRows.length\n\n    // 병합할 열의 수\n    let numberOfColumns = mergeableColumns.length\n\n    // 선택된 셀의 수\n    let numberOfCells = cells.length\n\n    // 병합될 조건 검사\n    // 행과 열의 곱이 셀의 수가 아니거나 셀의 수가 2보다 작은 경우는 병합하지 않는다.\n    if (numberOfCells !== numberOfRows * numberOfColumns || numberOfCells < 2) return false\n\n    // 선택한 셀들을 index 값이 낮은 것부터 순서대로 재정렬\n    cells.sort((a, b) => {\n      return (\n        this.getRowColumn(a).row * this.columns +\n        this.getRowColumn(a).column -\n        (this.getRowColumn(b).row * this.columns + this.getRowColumn(b).column)\n      )\n    })\n\n    // 셀을 병합함\n    let firstCell = cells[0]\n    firstCell.set({\n      colspan: numberOfColumns,\n      rowspan: numberOfRows\n    })\n\n    // 첫 번째 셀을 제외한 나머지 셀을 true로 지정\n    for (let i = 1; i < numberOfCells; i++) cells[i].merged = true\n\n    // 병합 후에는 첫 번째 셀을 선택하도록 함\n    this.root.selected = [firstCell]\n  }\n\n  splitCells(cells) {\n    // 선택한 병합된 셀의 정보를 가져온다.\n    let firstCellRowColumn = this.getRowColumn(cells[0])\n    let firstCell = cells[0]\n    let firstCellIndex = this.components.indexOf(cells[0])\n    let length = this.components.length\n    let lastCell = this.components[length - 1]\n    let lastCellRowColumn = this.getRowColumn(lastCell)\n    let startIndex = length / (lastCellRowColumn.row + 1)\n\n    // 병합된 셀들을 구해서 merged를 false로 설정한다.\n    // 자식 셀이 갖고 있는 부모 셀의 위치를 초기화 한다.\n    for (let j = 0; j < firstCell.rowspan; j++) {\n      let index\n      let nextCell\n      for (let i = firstCellIndex; i < firstCellIndex + firstCell.colspan; i++) {\n        index = startIndex * j + i\n        nextCell = this.components[index]\n        nextCell.merged = false\n      }\n    }\n\n    // 첫 번째 셀의 rowspan, colspan = 1로 지정한다.\n    firstCell.colspan = 1\n    firstCell.rowspan = 1\n  }\n\n  deleteRows(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    var heights = this.heights.slice()\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 지운다.\n      if (mergedCells.length === 0) {\n        this.remove(this.getCellsByRow(row))\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 지워야 한다.\n      //\n      else {\n        // 삭제할 행에서 병합된 셀을 삭제할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          let superCellRow = Math.floor(index / this.columns)\n          // 지우려는 행이 슈퍼셀을 포함한 경우이면서 슈퍼셀이 마지막 행의 셀이 아닌 경우\n          // 그리고 슈퍼셀의 rowspan이 1보다 큰 경우\n          if (row === superCellRow && superCellRow !== this.rows - 1 && this.components[index].rowspan > 1) {\n            this.components[index + this.columns].rowspan = this.components[index].rowspan - 1\n            this.components[index + this.columns].colspan = this.components[index].colspan\n            this.components[index + this.columns].merged = false\n            this.components[index + this.columns].set('text', this.components[index].get('text'))\n          } else {\n            this.components[index].rowspan -= 1\n          }\n        })\n        this.remove(this.getCellsByRow(row))\n      }\n    })\n    heights.splice(rows, 1)\n    this.model.rows -= rows.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n    this.set('heights', heights)\n  }\n\n  deleteColumns(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n\n    columns.forEach(column => {\n      var widths = this.widths.slice()\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 지운다.\n      if (mergedCells.length === 0) {\n        this.remove(this.getCellsByColumn(column))\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 지워야 한다.\n      else {\n        // 삭제할 열에서 병합된 셀을 삭제할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          let superCellColumn = index % this.columns\n          // 지우려는 열이 슈퍼셀을 포함한 경우이면서 슈퍼셀이 마지막 열의 셀이 아닌 경우\n          // 그리고 슈퍼셀의 colspan이 1보다 큰 경우\n          if (\n            column === superCellColumn &&\n            superCellColumn !== this.columns - 1 &&\n            this.components[index].colspan > 1\n          ) {\n            this.components[index + 1].rowspan = this.components[index].rowspan\n            this.components[index + 1].colspan = this.components[index].colspan - 1\n            this.components[index + 1].merged = false\n            this.components[index + 1].set('text', this.components[index].get('text'))\n          } else {\n            this.components[index].colspan -= 1\n          }\n        })\n        this.remove(this.getCellsByColumn(column))\n      }\n      widths.splice(column, 1)\n      this.model.columns -= 1 // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n      this.set('widths', widths)\n    })\n  }\n\n  insertCellsAbove(cells) {\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    // 행 2개 이상은 추가 안함. 임시로 막아놓음\n    if (rows.length >= 2) return false\n    let insertionRowPosition = rows[0]\n    let newbieRowHeights = []\n    let newbieCells = []\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 위에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.columns; i++)\n          newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n        newbieRowHeights.push(this.heights[row])\n\n        newbieCells.reverse().forEach(cell => {\n          this.insertComponentAt(cell, insertionRowPosition * this.columns)\n        })\n\n        let heights = this.heights.slice()\n        heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n        this.set('heights', heights)\n\n        this.model.rows += rows.length\n\n        this.clearCache()\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 추가해야 한다.\n      else {\n        // 선택한 행이 2개 이상 있고 그 중에 병합된 셀이 적어도 한 개라도 있으면\n        // 병합된 셀이 포함된 행의 추가는 무시한다. 임시방편으로 막아놈\n        if (rows.length > 1) return false\n        // 추가할 행에서 병합된 셀을 추가할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 행이 슈퍼셀을 포함한 경우\n          if (superCellRow === row) {\n            for (let i = 0; i < this.columns; i++) newbieCells.push(buildNewCell(this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index + this.columns].rowspan = superCellObj.rowspan\n            this.components[index + this.columns].colspan = superCellObj.colspan\n            this.components[index + this.columns].set('text', superCellObj.text)\n            this.components[index + this.columns].merged = superCellObj.merged\n          } else {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n          }\n          let heights = this.heights.slice()\n          heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n          this.set('heights', heights)\n\n          this.model.rows += rows.length\n\n          this.clearCache()\n        })\n      }\n    })\n  }\n\n  insertCellsBelow(cells) {\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    // 행 2개 이상은 추가 안함. 임시로 막아놓음\n    if (rows.length >= 2) return false\n    let insertionRowPosition = rows[rows.length - 1] + 1\n    let newbieRowHeights = []\n    let newbieCells = []\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 아래에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.columns; i++)\n          newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n        newbieRowHeights.push(this.heights[row])\n\n        newbieCells.reverse().forEach(cell => {\n          this.insertComponentAt(cell, insertionRowPosition * this.columns)\n        })\n\n        let heights = this.heights.slice()\n        heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n        this.set('heights', heights)\n\n        this.model.rows += 1\n\n        this.clearCache()\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 추가해야 한다.\n      else {\n        // 추가할 행에서 병합된 셀을 추가할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 행이 병합된 셀중 마지막 행인 경우\n          if (superCellRow + superCellObj.rowspan - 1 === row) {\n            for (let i = 0; i < this.columns; i++) newbieCells.push(buildNewCell(this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n          } else if (superCellRow === row) {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n            // 슈퍼셀이 복사됐으므로 그 해당 셀을 병합된 셀로 설정한다.\n            this.components[index + this.columns].rowspan = 1\n            this.components[index + this.columns].colspan = 1\n            this.components[index + this.columns].merged = true\n            this.components[index + this.columns].set('text', '')\n          } else {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n          }\n          let heights = this.heights.slice()\n          heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n          this.set('heights', heights)\n\n          this.model.rows += 1\n\n          this.clearCache()\n        })\n      }\n    })\n  }\n\n  insertCellsLeft(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[0]\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 왼쪽에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.rows; i++)\n          newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n        newbieColumnWidths.push(this.widths[column])\n\n        let increasedColumns = this.columns\n        let index = this.rows\n        newbieCells.reverse().forEach(cell => {\n          if (index == 0) {\n            index = this.rows\n            increasedColumns++\n          }\n\n          index--\n          this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n        })\n\n        let widths = this.widths.slice()\n        this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n        widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n        this.set('widths', widths)\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 추가해야 한다.\n      else {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellColumn = index % this.columns\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 열이 슈퍼셀을 포함한 경우\n          if (superCellColumn === column) {\n            for (let i = 0; i < this.rows; i++) newbieCells.push(buildNewCell(this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          } else {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          }\n          let widths = this.widths.slice()\n          this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n          widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n          this.set('widths', widths)\n        })\n      }\n    })\n  }\n\n  insertCellsRight(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[columns.length - 1] + 1\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 오른쪽에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.rows; i++)\n          newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n        newbieColumnWidths.push(this.widths[column])\n\n        let increasedColumns = this.columns\n        let index = this.rows\n        newbieCells.reverse().forEach(cell => {\n          if (index == 0) {\n            index = this.rows\n            increasedColumns++\n          }\n\n          index--\n          this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n        })\n\n        let widths = this.widths.slice()\n        this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n        widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n        this.set('widths', widths)\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 추가해야 한다.\n      else {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellColumn = index % this.columns\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 열이 병합된 셀중 마지막 열인 경우\n          if (superCellColumn + superCellObj.colspan - 1 === column) {\n            for (let i = 0; i < this.rows; i++) newbieCells.push(buildNewCell(this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          } else if (superCellColumn === column) {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n            // 슈퍼셀이 복사됐으므로 그 해당 셀을 병합된 셀로 설정한다.\n            this.components[index + superCellRow + 1].rowspan = 1\n            this.components[index + superCellRow + 1].colspan = 1\n            this.components[index + superCellRow + 1].merged = true\n            this.components[index + superCellRow + 1].set('text', '')\n          } else {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          }\n          let widths = this.widths.slice()\n          this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n          widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n          this.set('widths', widths)\n        })\n      }\n    })\n  }\n\n  distributeHorizontal(cells) {\n    var columns = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == columns.indexOf(rowcolumn.column)) columns.push(rowcolumn.column)\n    })\n\n    var sum = columns.reduce((sum, column) => {\n      return sum + this.widths[column]\n    }, 0)\n\n    var newval = Math.round((sum / columns.length) * 100) / 100\n    var widths = this.widths.slice()\n    columns.forEach(column => {\n      widths[column] = newval\n    })\n\n    this.set('widths', widths)\n  }\n\n  distributeVertical(cells) {\n    var rows = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == rows.indexOf(rowcolumn.row)) rows.push(rowcolumn.row)\n    })\n\n    var sum = rows.reduce((sum, row) => {\n      return sum + this.heights[row]\n    }, 0)\n\n    var newval = Math.round((sum / rows.length) * 100) / 100\n    var heights = this.heights.slice()\n    rows.forEach(row => {\n      heights[row] = newval\n    })\n\n    this.set('heights', heights)\n  }\n\n  toObjectArrayValue(array) {\n    if (!array || array.length === 0) return null\n\n    if (!array[0].hasOwnProperty('__field1')) {\n      return array\n    }\n\n    let indexKeyMap = {}\n    let value = []\n\n    for (let key in array[0]) {\n      indexKeyMap[key] = array[0][key]\n    }\n\n    for (var i = 1; i < array.length; i++) {\n      let object = {}\n      let thisObject = array[i]\n      for (let key in indexKeyMap) {\n        let k = indexKeyMap[key]\n        let v = thisObject[key]\n        object[k] = v\n      }\n\n      value.push(object)\n    }\n\n    return value\n  }\n\n  get columns() {\n    return Number(this.get('columns'))\n  }\n\n  get lefts() {\n    return this.components.filter((c, i) => {\n      return !(i % this.columns)\n    })\n  }\n\n  get centers() {\n    return this.components.filter((c, i) => {\n      return i % this.columns && (i + 1) % this.columns\n    })\n  }\n\n  get rights() {\n    return this.components.filter((c, i) => {\n      return !((i + 1) % this.columns)\n    })\n  }\n\n  get tops() {\n    return this.components.slice(0, this.columns)\n  }\n\n  get middles() {\n    return this.components.slice(this.columns, this.columns * (this.rows - 1))\n  }\n\n  get bottoms() {\n    return this.components.slice(this.columns * (this.rows - 1))\n  }\n\n  get widths_sum() {\n    var widths = this.widths\n    return widths ? widths.filter((width, i) => i < this.columns).reduce((sum, width) => sum + width, 0) : this.columns\n  }\n\n  get heights_sum() {\n    var heights = this.heights\n    return heights ? heights.filter((height, i) => i < this.rows).reduce((sum, height) => sum + height, 0) : this.rows\n  }\n\n  get nature() {\n    return NATURE\n  }\n\n  get controls() {\n    var widths = this.widths\n    var heights = this.heights\n    var inside = this.textBounds\n\n    var width_unit = inside.width / this.widths_sum\n    var height_unit = inside.height / this.heights_sum\n\n    var x = inside.left\n    var y = inside.top\n\n    var controls = []\n\n    widths.slice(0, this.columns - 1).forEach(width => {\n      x += width * width_unit\n      controls.push({\n        x: x,\n        y: inside.top,\n        handler: columnControlHandler\n      })\n    })\n\n    heights.slice(0, this.rows - 1).forEach(height => {\n      y += height * height_unit\n      controls.push({\n        x: inside.left,\n        y: y,\n        handler: rowControlHandler\n      })\n    })\n\n    return controls\n  }\n\n  onchange(after, before) {\n    if ('rows' in after || 'columns' in after) {\n      let { rows, columns } = this\n\n      this.buildCells(\n        rows,\n        columns,\n        'rows' in before ? before.rows : rows,\n        'columns' in before ? before.columns : columns\n      )\n    }\n\n    if ('data' in after) {\n      this.setCellsData()\n    }\n  }\n\n  get eventMap() {\n    return {\n      '(self)': {\n        '(descendant)': {\n          change: this.oncellchanged\n        }\n      }\n    }\n  }\n\n  oncellchanged(after, before) {\n    if ('dataKey' in after || 'dataIndex' in after) {\n      this.setCellsData()\n    }\n  }\n}\n\n;['rows', 'columns', 'widths', 'heights', 'widths_sum', 'heights_sum', 'controls'].forEach(getter =>\n  Component.memoize(Table.prototype, getter, false)\n)\n\nComponent.register('table', Table)\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport { Component, Container, RectPath, Layout } from '@hatiolab/things-scene'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'editor-table',\n      label: '',\n      name: '',\n      property: {\n        merge: true,\n        split: true\n      }\n    },\n    {\n      type: 'string',\n      label: 'data-key',\n      name: 'dataKey',\n      property: 'dataKey'\n    },\n    {\n      type: 'number',\n      label: 'data-index',\n      name: 'dataIndex',\n      property: 'dataIndex'\n    }\n  ]\n}\n\nconst EMPTY_BORDER = {}\n\nfunction isBottomMost(idx, rows, columns) {\n  return idx >= (rows - 1) * columns\n}\n\nfunction isRightMost(idx, rows, columns) {\n  return (idx + 1) % columns == 0\n}\n\n/**\n * 1. 스타일을 상속 받아야 함. (cascade-style)\n * 2. 스타일을 동적처리할 수 있음. (로직처리)\n * 3. 데이타를 받을 수 있음.\n */\nexport default class TableCell extends RectPath(Component) {\n  // export default class TableCell extends Container {\n\n  // get layout() {\n  //   return Layout.get(this.get('layout') || 'card')\n  // }\n\n  get nature() {\n    return NATURE\n  }\n\n  set merged(merged) {\n    this.set('merged', !!merged)\n    if (merged) this.set('text', '')\n  }\n\n  get merged() {\n    return this.get('merged')\n  }\n\n  set rowspan(rowspan) {\n    this.set('rowspan', rowspan)\n  }\n\n  get rowspan() {\n    return this.get('rowspan')\n  }\n\n  set colspan(colspan) {\n    this.set('colspan', colspan)\n  }\n\n  get colspan() {\n    return this.get('colspan')\n  }\n\n  get border() {\n    var border = this.model.border || EMPTY_BORDER\n  }\n\n  _drawBorder(context, x, y, to_x, to_y, style) {\n    if (style && style.strokeStyle && style.lineWidth && style.lineDash) {\n      context.beginPath()\n      context.moveTo(x, y)\n      context.lineTo(to_x, to_y)\n      Component.drawStroke(context, style)\n    }\n  }\n\n  _draw(context) {\n    var { left, top, width, height } = this.model\n\n    var border = this.model.border || {}\n\n    // Cell 채우기.\n    context.beginPath()\n    context.lineWidth = 0\n    context.rect(left, top, width, height)\n    this.drawFill(context)\n\n    // Border 그리기\n    var parent = this.parent\n    var idx = parent.components.indexOf(this)\n    var columns = parent.columns || 1\n    var rows = parent.rows || 1\n\n    this._drawBorder(context, left, top, left + width, top, border.top)\n    this._drawBorder(context, left, top + height, left, top, border.left)\n    if (isRightMost(idx, rows, columns))\n      this._drawBorder(context, left + width, top, left + width, top + height, border.right)\n    if (isBottomMost(idx, rows, columns))\n      this._drawBorder(context, left + width, top + height, left, top + height, border.bottom)\n  }\n}\n\n;['border'].forEach(getter => Component.memoize(TableCell.prototype, getter, false))\n\nComponent.register('table-cell', TableCell)\n"],"names":["NATURE","mutable","resizable","rotatable","properties","type","label","name","property","options","SIDES","all","out","left","right","top","bottom","leftright","topbottom","CLEAR_STYLE","strokeStyle","lineDash","lineWidth","DEFAULT_STYLE","TABLE_LAYOUT","Layout","get","buildNewCell","app","Model","compile","width","height","textWrap","border","buildBorderStyle","buildCopiedCell","copy","obj","JSON","parse","stringify","text","style","where","reduce","side","setCellBorder","cell","set","Object","assign","isLeftMost","total","columns","indices","i","indexOf","isRightMost","isTopMost","isBottomMost","above","below","before","after","array","value","size","arr","push","columnControlHandler","ondragmove","point","index","component","textBounds","widths_sum","widths","slice","origin_offset","sum","diff_unit","transcoordP2S","x","y","min_width_unit","Math","min","round","rowControlHandler","heights_sum","heights","min_height_unit","Table","Container","tobeSize","this","rows","gap","removals","_components","remove","newbies","add","length","newrows","newcolumns","oldrows","oldcolumns","mergedCells","forEach","merged","rowspan","colspan","superCells","superCellIndexes","col","row","_this","components","floor","spColStart","spColEnd","spRowStart","spRowEnd","minrows","r","c","insertComponentAt","cells","_cells","_this2","getRowColumn","column","j","map","data","toObjectArrayValue","state","spreadTo","dataKey","model","dataIndex","idx","mergeableRows","_this3","mergeableColumns","numberOfRows","numberOfColumns","numberOfCells","sort","a","b","firstCell","root","selected","firstCellIndex","lastCell","startIndex","_this4","reverse","findMergedCellByX","getCellsByRow","superCellRow","splice","_this5","findMergedCellByY","getCellsByColumn","superCellColumn","_this6","insertionRowPosition","newbieRowHeights","newbieCells","clearCache","superCellObj","_this7","_this8","insertionColumnPosition","newbieColumnWidths","increasedColumns","rowIndex","_this9","rowcolumn","_this10","newval","_this11","hasOwnProperty","indexKeyMap","key","object","thisObject","k","v","buildCells","setCellsData","concat","Number","filter","_this12","_this13","_this14","_this15","_this16","inside","width_unit","height_unit","controls","handler","change","oncellchanged","getter","Component","memoize","prototype","register","merge","split","TableCell","RectPath","context","to_x","to_y","beginPath","moveTo","lineTo","drawStroke","rect","drawFill","parent","_drawBorder"],"mappings":"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"}