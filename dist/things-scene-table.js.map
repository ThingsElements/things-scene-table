{"version":3,"file":"things-scene-table.js","sources":["../src/helper-functions.js","../src/table.js","../src/table-cell.js","../src/data-list/data-cell.js","../src/data-list/data-list-layout.js","../src/data-list/data-list.js"],"sourcesContent":["import { Model } from '@hatiolab/things-scene'\n\nexport const SIDES = {\n  all: ['top', 'left', 'bottom', 'right'],\n  out: ['top', 'left', 'bottom', 'right'],\n  left: ['left'],\n  right: ['right'],\n  top: ['top'],\n  bottom: ['bottom'],\n  leftright: ['left', 'right'],\n  topbottom: ['top', 'bottom']\n}\n\nexport const CLEAR_STYLE = {\n  strokeStyle: '',\n  lineDash: 'solid',\n  lineWidth: 0\n}\n\nexport const DEFAULT_STYLE = {\n  strokeStyle: '#999',\n  lineDash: 'solid',\n  lineWidth: 1\n}\n\nexport function buildNewCell(type, app) {\n  return Model.compile(\n    {\n      type,\n      strokeStyle: 'blue',\n      left: 0,\n      top: 0,\n      width: 1,\n      height: 1,\n      textWrap: true,\n      border: buildBorderStyle(DEFAULT_STYLE, 'all')\n    },\n    app\n  )\n}\n\nexport function buildCopiedCell(copy, app) {\n  var obj = JSON.parse(JSON.stringify(copy))\n  delete obj.text\n  return Model.compile(obj, app)\n}\n\nexport function buildBorderStyle(style, where) {\n  return (SIDES[where] || []).reduce((border, side) => {\n    border[side] = style\n    return border\n  }, {})\n}\n\nexport function setCellBorder(cell, style, where) {\n  if (!cell) return\n  cell.set('border', Object.assign({}, cell.get('border') || {}, buildBorderStyle(style, where)))\n}\n\nexport function isLeftMost(total, columns, indices, i) {\n  return i == 0 || !(i % columns) || indices.indexOf(i - 1) == -1\n}\n\nexport function isRightMost(total, columns, indices, i) {\n  return i == total - 1 || i % columns == columns - 1 || indices.indexOf(i + 1) == -1\n}\n\nexport function isTopMost(total, columns, indices, i) {\n  return i < columns || indices.indexOf(i - columns) == -1\n}\n\nexport function isBottomMost(total, columns, indices, i) {\n  return i > total - columns - 1 || indices.indexOf(i + columns) == -1\n}\n\nexport function above(columns, i) {\n  return i - columns\n}\n\nexport function below(columns, i) {\n  return i + columns\n}\n\nexport function before(columns, i) {\n  return !(i % columns) ? -1 : i - 1\n}\n\nexport function after(columns, i) {\n  return !((i + 1) % columns) ? -1 : i + 1\n}\n\nexport function array(value, size) {\n  var arr = []\n  for (let i = 0; i < size; i++) arr.push(1)\n  return arr\n}\n\nexport var columnControlHandler = {\n  ondragmove: function(point, index, component) {\n    var { left, width } = component.textBounds\n    var widths_sum = component.widths_sum\n\n    var widths = component.widths.slice()\n\n    /* 컨트롤의 원래 위치를 구한다. */\n    var origin_pos_unit = widths.slice(0, index + 1).reduce((sum, width) => sum + width, 0)\n    var origin_offset = left + (origin_pos_unit / widths_sum) * width\n\n    /*\n     * point의 좌표는 부모 레이어 기준의 x, y 값이다.\n     * 따라서, 도형의 회전을 감안한 좌표로의 변환이 필요하다.\n     * Transcoord시에는 point좌표가 부모까지 transcoord되어있는 상태이므로,\n     * 컴포넌트자신에 대한 transcoord만 필요하다.(마지막 파라미터를 false로).\n     */\n    var transcoorded = component.transcoordP2S(point.x, point.y)\n    var diff = transcoorded.x - origin_offset\n\n    var diff_unit = (diff / width) * widths_sum\n\n    var min_width_unit = (widths_sum / width) * 10 // 10픽셀정도를 최소로\n\n    if (diff_unit < 0) diff_unit = -Math.min(widths[index] - min_width_unit, -diff_unit)\n    else diff_unit = Math.min(widths[index + 1] - min_width_unit, diff_unit)\n\n    widths[index] = Math.round((widths[index] + diff_unit) * 100) / 100\n    widths[index + 1] = Math.round((widths[index + 1] - diff_unit) * 100) / 100\n\n    component.set('widths', widths)\n  }\n}\n\nexport var rowControlHandler = {\n  ondragmove: function(point, index, component) {\n    var { top, height } = component.textBounds\n    var heights_sum = component.heights_sum\n\n    var heights = component.heights.slice()\n\n    /* 컨트롤의 원래 위치를 구한다. */\n    index -= component.columns - 1\n    var origin_pos_unit = heights.slice(0, index + 1).reduce((sum, height) => sum + height, 0)\n    var origin_offset = top + (origin_pos_unit / heights_sum) * height\n\n    /*\n     * point의 좌표는 부모 레이어 기준의 x, y 값이다.\n     * 따라서, 도형의 회전을 감안한 좌표로의 변환이 필요하다.\n     * Transcoord시에는 point좌표가 부모까지 transcoord되어있는 상태이므로,\n     * 컴포넌트자신에 대한 transcoord만 필요하다.(마지막 파라미터를 false로).\n     */\n    var transcoorded = component.transcoordP2S(point.x, point.y)\n    var diff = transcoorded.y - origin_offset\n\n    var diff_unit = (diff / height) * heights_sum\n\n    var min_height_unit = (heights_sum / height) * 10 // 10픽셀정도를 최소로\n\n    if (diff_unit < 0) diff_unit = -Math.min(heights[index] - min_height_unit, -diff_unit)\n    else diff_unit = Math.min(heights[index + 1] - min_height_unit, diff_unit)\n\n    heights[index] = Math.round((heights[index] + diff_unit) * 100) / 100\n    heights[index + 1] = Math.round((heights[index + 1] - diff_unit) * 100) / 100\n\n    component.set('heights', heights)\n  }\n}\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport { Component, Container, Layout } from '@hatiolab/things-scene'\nimport {\n  CLEAR_STYLE,\n  buildNewCell,\n  buildCopiedCell,\n  setCellBorder,\n  isLeftMost,\n  isRightMost,\n  isTopMost,\n  isBottomMost,\n  above,\n  below,\n  before,\n  after,\n  array,\n  columnControlHandler,\n  rowControlHandler\n} from './helper-functions'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'number',\n      label: 'rows',\n      name: 'rows',\n      property: 'rows'\n    },\n    {\n      type: 'number',\n      label: 'columns',\n      name: 'columns',\n      property: 'columns'\n    },\n    {\n      type: 'select',\n      label: 'data-spread-to',\n      name: 'spreadTo',\n      property: {\n        options: ['text', 'data']\n      }\n    }\n  ],\n  'value-property': 'data'\n}\n\nexport default class Table extends Container {\n  created() {\n    var tobeSize = this.rows * this.columns\n    var gap = this.size() - tobeSize\n\n    if (gap == 0) {\n      return\n    } else if (gap > 0) {\n      let removals = this._components.slice(gap)\n      this.remove(removals)\n    } else {\n      let newbies = []\n\n      for (let i = 0; i < -gap; i++) newbies.push(buildNewCell('table-cell', this.app))\n\n      this.add(newbies)\n    }\n\n    var widths = this.get('widths')\n    var heights = this.get('heights')\n\n    if (!widths || widths.length < this.columns) this.set('widths', this.widths)\n    if (!heights || heights.length < this.rows) this.set('heights', this.heights)\n  }\n\n  containable(component) {\n    return component.get('type') == 'table-cell'\n  }\n\n  get focusible() {\n    /* 이 컨테이너에는 컴포넌트를 임의로 추가 및 삭제할 수 없도록 함 */\n    return false\n  }\n\n  get widths() {\n    var widths = this.get('widths')\n\n    if (!widths) return array(1, this.columns)\n\n    if (widths.length < this.columns) return widths.concat(array(1, this.columns - widths.length))\n    else if (widths.length > this.columns) return widths.slice(0, this.columns)\n\n    return widths\n  }\n\n  get heights() {\n    var heights = this.get('heights')\n\n    if (!heights) return array(1, this.rows)\n\n    if (heights.length < this.rows) return heights.concat(array(1, this.rows - heights.length))\n    else if (heights.length > this.rows) return heights.slice(0, this.rows)\n\n    return heights\n  }\n\n  buildCells(newrows, newcolumns, oldrows, oldcolumns) {\n    if (newrows < oldrows) {\n      let removals = this._components.slice(oldcolumns * newrows)\n\n      // 지우려는 셀중에 병합된 셀을 찾는다.\n      let mergedCells = []\n      removals.forEach(cell => {\n        if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n      })\n\n      // 병합된 셀 중에서 슈퍼셀을 찾는다.\n      if (mergedCells.length > 0) {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.components.indexOf(cell) % oldcolumns\n          row = Math.floor(this.components.indexOf(cell) / oldcolumns)\n          index = row * oldcolumns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.components.indexOf(component) % oldcolumns\n              let spColEnd = (this.components.indexOf(component) % oldcolumns) + component.colspan\n              let spRowStart = Math.floor(this.components.indexOf(component) / oldcolumns)\n              let spRowEnd = Math.floor(this.components.indexOf(component) / oldcolumns) + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        // 슈퍼셀에서 colspan 을 감소시킨다\n        superCells.forEach(cell => {\n          // newcolumns < oldcolumns 케이스와 이 부분만 다름\n          cell.rowspan -= oldrows - newrows\n        })\n      }\n\n      this.remove(removals)\n    }\n\n    var minrows = Math.min(newrows, oldrows)\n\n    if (newcolumns > oldcolumns) {\n      for (let r = 0; r < minrows; r++) {\n        for (let c = oldcolumns; c < newcolumns; c++) {\n          this.insertComponentAt(buildNewCell('table-cell', this.app), r * newcolumns + c)\n        }\n      }\n    } else if (newcolumns < oldcolumns) {\n      let removals = []\n\n      for (let r = 0; r < minrows; r++) {\n        for (let c = newcolumns; c < oldcolumns; c++) {\n          removals.push(this.components[r * oldcolumns + c])\n        }\n      }\n      // 지우려는 셀중에 병합된 셀을 찾는다.\n      let mergedCells = []\n      removals.forEach(cell => {\n        if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n      })\n\n      // 병합된 셀 중에서 슈퍼셀을 찾는다.\n      if (mergedCells.length > 0) {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.components.indexOf(cell) % oldcolumns\n          row = Math.floor(this.components.indexOf(cell) / oldcolumns)\n          index = row * oldcolumns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.components.indexOf(component) % oldcolumns\n              let spColEnd = (this.components.indexOf(component) % oldcolumns) + component.colspan\n              let spRowStart = Math.floor(this.components.indexOf(component) / oldcolumns)\n              let spRowEnd = Math.floor(this.components.indexOf(component) / oldcolumns) + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        // 슈퍼셀에서 colspan 을 감소시킨다\n        superCells.forEach(cell => {\n          cell.colspan -= oldcolumns - newcolumns\n        })\n      }\n\n      this.remove(removals)\n    }\n\n    if (newrows > oldrows) {\n      let newbies = []\n\n      for (let r = oldrows; r < newrows; r++) {\n        for (let i = 0; i < newcolumns; i++) {\n          newbies.push(buildNewCell('table-cell', this.app))\n        }\n      }\n      this.add(newbies)\n    }\n\n    this.set({\n      widths: this.widths,\n      heights: this.heights\n    })\n  }\n\n  get layout() {\n    return Layout.get('table')\n  }\n\n  get rows() {\n    return Number(this.get('rows'))\n  }\n\n  setCellsStyle(cells, style, where) {\n    var components = this.components\n    var total = components.length\n    var columns = this.get('columns')\n\n    // 병합된 셀도 포함시킨다.\n    var _cells = []\n    cells.forEach(c => {\n      _cells.push(c)\n      if (c.colspan || c.rowspan) {\n        let col = this.getRowColumn(c).column\n        let row = this.getRowColumn(c).row\n        for (let i = row; i < row + c.rowspan; i++)\n          for (let j = col; j < col + c.colspan; j++)\n            if (i != row || j != col) _cells.push(this.components[i * this.columns + j])\n      }\n    })\n    var indices = _cells.map(cell => components.indexOf(cell))\n    indices.forEach(i => {\n      var cell = components[i]\n\n      switch (where) {\n        case 'all':\n          setCellBorder(cell, style, where)\n\n          if (isLeftMost(total, columns, indices, i)) setCellBorder(components[before(columns, i)], style, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], style, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], style, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], style, 'top')\n          break\n        case 'in':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'out':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'left':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          break\n        case 'right':\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          break\n        case 'center':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          break\n        case 'middle':\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'top':\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          break\n        case 'bottom':\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'clear':\n          setCellBorder(cell, CLEAR_STYLE, 'all')\n\n          if (isLeftMost(total, columns, indices, i))\n            setCellBorder(components[before(columns, i)], CLEAR_STYLE, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], CLEAR_STYLE, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], CLEAR_STYLE, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], CLEAR_STYLE, 'top')\n      }\n    })\n  }\n\n  setCellsData() {\n    var data = this.data\n\n    if (!data) return\n\n    data = this.toObjectArrayValue(data) || []\n\n    var cells = this.components\n\n    var { spreadTo = 'text' } = this.state\n\n    cells.forEach(cell => {\n      var dataKey = cell.model.dataKey\n      var dataIndex = cell.model.dataIndex\n      if (dataKey && dataIndex >= 0) cell[spreadTo] = (data[dataIndex] || {})[dataKey]\n    })\n  }\n\n  getRowColumn(cell) {\n    var idx = this.components.indexOf(cell)\n\n    return {\n      column: idx % this.columns,\n      row: Math.floor(idx / this.columns)\n    }\n  }\n\n  getCellsByRow(row) {\n    return this.components.slice(row * this.columns, (row + 1) * this.columns)\n  }\n\n  getCellsByColumn(column) {\n    var cells = []\n    for (var i = 0; i < this.rows; i++) cells.push(this.components[this.columns * i + column])\n\n    return cells\n  }\n\n  // 한 개의 행을 매개변수로 받아서 첫 번째 셀부터 우측으로 이동하면서 병합된 셀이 있는지 검사한다.\n  findMergedCellByX(row) {\n    let mergedCells = []\n    let cell\n    for (let i = 0; i < this.columns; i++) {\n      cell = this.components[row * this.columns + i]\n      if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n    }\n    return mergedCells\n  }\n\n  // 한 개의 열을 매개변수로 받아서 첫 번째 셀부터 아래로 이동하면서 병합된 셀이 있는지 검사한다.\n  findMergedCellByY(column) {\n    let mergedCells = []\n    let cell\n    for (let i = 0; i < this.rows; i++) {\n      cell = this.components[i * this.columns + column]\n      if (cell.merged === true || cell.rowspan > 1 || cell.colspan > 1) mergedCells.push(cell)\n    }\n    return mergedCells\n  }\n\n  mergeCells(cells) {\n    // 선택한 셀이 들어있는 행\n    let mergeableRows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == mergeableRows.indexOf(row)) mergeableRows.push(row)\n    })\n\n    // 선택한 셀의 행이 연속적인 숫자가 아니라면 병합하지 않는다.\n    if (mergeableRows.length - 1 !== mergeableRows[mergeableRows.length - 1] - mergeableRows[0]) return false\n\n    // 선택한 셀이 들어있는 열\n    let mergeableColumns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == mergeableColumns.indexOf(column)) mergeableColumns.push(column)\n    })\n\n    // 선택한 셀의 열이 연속적인 숫자가 아니라면 병합하지 않는다.\n    if (mergeableColumns.length - 1 !== mergeableColumns[mergeableColumns.length - 1] - mergeableColumns[0])\n      return false\n\n    // 병합할 행의 수\n    let numberOfRows = mergeableRows.length\n\n    // 병합할 열의 수\n    let numberOfColumns = mergeableColumns.length\n\n    // 선택된 셀의 수\n    let numberOfCells = cells.length\n\n    // 병합될 조건 검사\n    // 행과 열의 곱이 셀의 수가 아니거나 셀의 수가 2보다 작은 경우는 병합하지 않는다.\n    if (numberOfCells !== numberOfRows * numberOfColumns || numberOfCells < 2) return false\n\n    // 선택한 셀들을 index 값이 낮은 것부터 순서대로 재정렬\n    cells.sort((a, b) => {\n      return (\n        this.getRowColumn(a).row * this.columns +\n        this.getRowColumn(a).column -\n        (this.getRowColumn(b).row * this.columns + this.getRowColumn(b).column)\n      )\n    })\n\n    // 셀을 병합함\n    let firstCell = cells[0]\n    firstCell.set({\n      colspan: numberOfColumns,\n      rowspan: numberOfRows\n    })\n\n    // 첫 번째 셀을 제외한 나머지 셀을 true로 지정\n    for (let i = 1; i < numberOfCells; i++) cells[i].merged = true\n\n    // 병합 후에는 첫 번째 셀을 선택하도록 함\n    this.root.selected = [firstCell]\n  }\n\n  splitCells(cells) {\n    // 선택한 병합된 셀의 정보를 가져온다.\n    let firstCellRowColumn = this.getRowColumn(cells[0])\n    let firstCell = cells[0]\n    let firstCellIndex = this.components.indexOf(cells[0])\n    let length = this.components.length\n    let lastCell = this.components[length - 1]\n    let lastCellRowColumn = this.getRowColumn(lastCell)\n    let startIndex = length / (lastCellRowColumn.row + 1)\n\n    // 병합된 셀들을 구해서 merged를 false로 설정한다.\n    // 자식 셀이 갖고 있는 부모 셀의 위치를 초기화 한다.\n    for (let j = 0; j < firstCell.rowspan; j++) {\n      let index\n      let nextCell\n      for (let i = firstCellIndex; i < firstCellIndex + firstCell.colspan; i++) {\n        index = startIndex * j + i\n        nextCell = this.components[index]\n        nextCell.merged = false\n      }\n    }\n\n    // 첫 번째 셀의 rowspan, colspan = 1로 지정한다.\n    firstCell.colspan = 1\n    firstCell.rowspan = 1\n  }\n\n  deleteRows(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    var heights = this.heights.slice()\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 지운다.\n      if (mergedCells.length === 0) {\n        this.remove(this.getCellsByRow(row))\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 지워야 한다.\n      //\n      else {\n        // 삭제할 행에서 병합된 셀을 삭제할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          let superCellRow = Math.floor(index / this.columns)\n          // 지우려는 행이 슈퍼셀을 포함한 경우이면서 슈퍼셀이 마지막 행의 셀이 아닌 경우\n          // 그리고 슈퍼셀의 rowspan이 1보다 큰 경우\n          if (row === superCellRow && superCellRow !== this.rows - 1 && this.components[index].rowspan > 1) {\n            this.components[index + this.columns].rowspan = this.components[index].rowspan - 1\n            this.components[index + this.columns].colspan = this.components[index].colspan\n            this.components[index + this.columns].merged = false\n            this.components[index + this.columns].set('text', this.components[index].get('text'))\n          } else {\n            this.components[index].rowspan -= 1\n          }\n        })\n        this.remove(this.getCellsByRow(row))\n      }\n    })\n    heights.splice(rows, 1)\n    this.model.rows -= rows.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n    this.set('heights', heights)\n  }\n\n  deleteColumns(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n\n    columns.forEach(column => {\n      var widths = this.widths.slice()\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 지운다.\n      if (mergedCells.length === 0) {\n        this.remove(this.getCellsByColumn(column))\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 지워야 한다.\n      else {\n        // 삭제할 열에서 병합된 셀을 삭제할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스를 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          let superCellColumn = index % this.columns\n          // 지우려는 열이 슈퍼셀을 포함한 경우이면서 슈퍼셀이 마지막 열의 셀이 아닌 경우\n          // 그리고 슈퍼셀의 colspan이 1보다 큰 경우\n          if (\n            column === superCellColumn &&\n            superCellColumn !== this.columns - 1 &&\n            this.components[index].colspan > 1\n          ) {\n            this.components[index + 1].rowspan = this.components[index].rowspan\n            this.components[index + 1].colspan = this.components[index].colspan - 1\n            this.components[index + 1].merged = false\n            this.components[index + 1].set('text', this.components[index].get('text'))\n          } else {\n            this.components[index].colspan -= 1\n          }\n        })\n        this.remove(this.getCellsByColumn(column))\n      }\n      widths.splice(column, 1)\n      this.model.columns -= 1 // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n      this.set('widths', widths)\n    })\n  }\n\n  insertCellsAbove(cells) {\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    // 행 2개 이상은 추가 안함. 임시로 막아놓음\n    if (rows.length >= 2) return false\n    let insertionRowPosition = rows[0]\n    let newbieRowHeights = []\n    let newbieCells = []\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 위에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.columns; i++)\n          newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n        newbieRowHeights.push(this.heights[row])\n\n        newbieCells.reverse().forEach(cell => {\n          this.insertComponentAt(cell, insertionRowPosition * this.columns)\n        })\n\n        let heights = this.heights.slice()\n        heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n        this.set('heights', heights)\n\n        this.model.rows += rows.length\n\n        this.clearCache()\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 추가해야 한다.\n      else {\n        // 선택한 행이 2개 이상 있고 그 중에 병합된 셀이 적어도 한 개라도 있으면\n        // 병합된 셀이 포함된 행의 추가는 무시한다. 임시방편으로 막아놈\n        if (rows.length > 1) return false\n        // 추가할 행에서 병합된 셀을 추가할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 행이 슈퍼셀을 포함한 경우\n          if (superCellRow === row) {\n            for (let i = 0; i < this.columns; i++) newbieCells.push(buildNewCell('table-cell', this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index + this.columns].rowspan = superCellObj.rowspan\n            this.components[index + this.columns].colspan = superCellObj.colspan\n            this.components[index + this.columns].set('text', superCellObj.text)\n            this.components[index + this.columns].merged = superCellObj.merged\n          } else {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n          }\n          let heights = this.heights.slice()\n          heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n          this.set('heights', heights)\n\n          this.model.rows += rows.length\n\n          this.clearCache()\n        })\n      }\n    })\n  }\n\n  insertCellsBelow(cells) {\n    // 먼저 cells 위치의 행을 구한다.\n    let rows = []\n    cells.forEach(cell => {\n      let row = this.getRowColumn(cell).row\n      if (-1 == rows.indexOf(row)) rows.push(row)\n    })\n    rows.sort((a, b) => {\n      return a - b\n    })\n    rows.reverse()\n    // 행 2개 이상은 추가 안함. 임시로 막아놓음\n    if (rows.length >= 2) return false\n    let insertionRowPosition = rows[rows.length - 1] + 1\n    let newbieRowHeights = []\n    let newbieCells = []\n    rows.forEach(row => {\n      // rows에서 가로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByX(row)\n      // mergedCells.length가 0이면 일반적으로 행을 아래에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.columns; i++)\n          newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n        newbieRowHeights.push(this.heights[row])\n\n        newbieCells.reverse().forEach(cell => {\n          this.insertComponentAt(cell, insertionRowPosition * this.columns)\n        })\n\n        let heights = this.heights.slice()\n        heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n        this.set('heights', heights)\n\n        this.model.rows += 1\n\n        this.clearCache()\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 행을 추가해야 한다.\n      else {\n        // 추가할 행에서 병합된 셀을 추가할 때 해당 셀을 임시로 저장\n        let temp = []\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 행이 병합된 셀중 마지막 행인 경우\n          if (superCellRow + superCellObj.rowspan - 1 === row) {\n            for (let i = 0; i < this.columns; i++) newbieCells.push(buildNewCell('table-cell', this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n          } else if (superCellRow === row) {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n            // 슈퍼셀이 복사됐으므로 그 해당 셀을 병합된 셀로 설정한다.\n            this.components[index + this.columns].rowspan = 1\n            this.components[index + this.columns].colspan = 1\n            this.components[index + this.columns].merged = true\n            this.components[index + this.columns].set('text', '')\n          } else {\n            for (let i = 0; i < this.columns; i++)\n              newbieCells.push(buildCopiedCell(this.components[row * this.columns + i].model, this.app))\n            newbieRowHeights.push(this.heights[row])\n\n            newbieCells.reverse().forEach(cell => {\n              this.insertComponentAt(cell, insertionRowPosition * this.columns)\n            })\n            this.components[index].rowspan += 1\n          }\n          let heights = this.heights.slice()\n          heights.splice(insertionRowPosition, 0, ...newbieRowHeights)\n          this.set('heights', heights)\n\n          this.model.rows += 1\n\n          this.clearCache()\n        })\n      }\n    })\n  }\n\n  insertCellsLeft(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[0]\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 왼쪽에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.rows; i++)\n          newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n        newbieColumnWidths.push(this.widths[column])\n\n        let increasedColumns = this.columns\n        let index = this.rows\n        newbieCells.reverse().forEach(cell => {\n          if (index == 0) {\n            index = this.rows\n            increasedColumns++\n          }\n\n          index--\n          this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n        })\n\n        let widths = this.widths.slice()\n        this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n        widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n        this.set('widths', widths)\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 추가해야 한다.\n      else {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellColumn = index % this.columns\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 열이 슈퍼셀을 포함한 경우\n          if (superCellColumn === column) {\n            for (let i = 0; i < this.rows; i++) newbieCells.push(buildNewCell('table-cell', this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          } else {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          }\n          let widths = this.widths.slice()\n          this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n          widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n          this.set('widths', widths)\n        })\n      }\n    })\n  }\n\n  insertCellsRight(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[columns.length - 1] + 1\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      // columns에서 세로 방향으로 이동하면서 병합된 셀을 찾는다.\n      let mergedCells = this.findMergedCellByY(column)\n      // mergedCells.length가 0이면 일반적으로 열을 오른쪽에 추가한다.\n      if (mergedCells.length === 0) {\n        for (let i = 0; i < this.rows; i++)\n          newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n        newbieColumnWidths.push(this.widths[column])\n\n        let increasedColumns = this.columns\n        let index = this.rows\n        newbieCells.reverse().forEach(cell => {\n          if (index == 0) {\n            index = this.rows\n            increasedColumns++\n          }\n\n          index--\n          this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n        })\n\n        let widths = this.widths.slice()\n        this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n        widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n        this.set('widths', widths)\n      }\n      // mergedCells.length가 0이 아니면 병합된 셀을 고려하여 열을 추가해야 한다.\n      else {\n        // 부모 셀을 저장\n        let superCells = []\n        // 부모 셀의 인덱스 값을 저장\n        let superCellIndexes = []\n        mergedCells.forEach(cell => {\n          let col, row, index\n          col = this.getRowColumn(cell).column\n          row = this.getRowColumn(cell).row\n          index = row * this.columns + col + 1\n          while (index) {\n            --index\n            let component = this.components[index]\n            // 슈퍼셀을 찾고 슈퍼셀의 위치에서 rowspan, colspan 거리만큼 이동하면서 cell이 있는지 검증해야함\n            if (component.rowspan > 1 || component.colspan > 1) {\n              let spColStart = this.getRowColumn(component).column\n              let spColEnd = this.getRowColumn(component).column + component.colspan\n              let spRowStart = this.getRowColumn(component).row\n              let spRowEnd = this.getRowColumn(component).row + component.rowspan\n              // 슈퍼셀 영역 안에 자식 셀이 있으면 superCells에 부모셀을 추가\n              if (col >= spColStart && col < spColEnd && (row >= spRowStart && row < spRowEnd)) {\n                if (-1 == superCellIndexes.indexOf(index)) {\n                  superCellIndexes.push(index)\n                  superCells.push(component)\n                }\n              }\n            }\n          }\n        })\n        superCellIndexes.forEach(index => {\n          // 추가하려는 셀은 일반 셀인데 그 위치에 다른 병합된 셀이 있는 문제로 임시로 막아 놓음. 수정해야함\n          if (superCellIndexes.length >= 2) return false\n          let superCellRow = Math.floor(index / this.columns)\n          let superCellColumn = index % this.columns\n          let superCellObj = {\n            rowspan: this.components[index].rowspan,\n            colspan: this.components[index].colspan,\n            text: this.components[index].get('text'),\n            merged: this.components[index].merged\n          }\n          // 추가하려는 열이 병합된 셀중 마지막 열인 경우\n          if (superCellColumn + superCellObj.colspan - 1 === column) {\n            for (let i = 0; i < this.rows; i++) newbieCells.push(buildNewCell('table-cell', this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          } else if (superCellColumn === column) {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n            // 슈퍼셀이 복사됐으므로 그 해당 셀을 병합된 셀로 설정한다.\n            this.components[index + superCellRow + 1].rowspan = 1\n            this.components[index + superCellRow + 1].colspan = 1\n            this.components[index + superCellRow + 1].merged = true\n            this.components[index + superCellRow + 1].set('text', '')\n          } else {\n            this.components[index].colspan += 1\n            for (let i = 0; i < this.rows; i++)\n              newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n            newbieColumnWidths.push(this.widths[column])\n\n            let increasedColumns = this.columns\n            let rowIndex = this.rows\n            newbieCells.reverse().forEach(cell => {\n              if (rowIndex == 0) {\n                rowIndex = this.rows\n                increasedColumns++\n              }\n\n              rowIndex--\n              this.insertComponentAt(cell, insertionColumnPosition + rowIndex * increasedColumns)\n            })\n          }\n          let widths = this.widths.slice()\n          this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n          widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n          this.set('widths', widths)\n        })\n      }\n    })\n  }\n\n  distributeHorizontal(cells) {\n    var columns = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == columns.indexOf(rowcolumn.column)) columns.push(rowcolumn.column)\n    })\n\n    var sum = columns.reduce((sum, column) => {\n      return sum + this.widths[column]\n    }, 0)\n\n    var newval = Math.round((sum / columns.length) * 100) / 100\n    var widths = this.widths.slice()\n    columns.forEach(column => {\n      widths[column] = newval\n    })\n\n    this.set('widths', widths)\n  }\n\n  distributeVertical(cells) {\n    var rows = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == rows.indexOf(rowcolumn.row)) rows.push(rowcolumn.row)\n    })\n\n    var sum = rows.reduce((sum, row) => {\n      return sum + this.heights[row]\n    }, 0)\n\n    var newval = Math.round((sum / rows.length) * 100) / 100\n    var heights = this.heights.slice()\n    rows.forEach(row => {\n      heights[row] = newval\n    })\n\n    this.set('heights', heights)\n  }\n\n  toObjectArrayValue(array) {\n    if (!array || array.length === 0) return null\n\n    if (!array[0].hasOwnProperty('__field1')) {\n      return array\n    }\n\n    let indexKeyMap = {}\n    let value = []\n\n    for (let key in array[0]) {\n      indexKeyMap[key] = array[0][key]\n    }\n\n    for (var i = 1; i < array.length; i++) {\n      let object = {}\n      let thisObject = array[i]\n      for (let key in indexKeyMap) {\n        let k = indexKeyMap[key]\n        let v = thisObject[key]\n        object[k] = v\n      }\n\n      value.push(object)\n    }\n\n    return value\n  }\n\n  get columns() {\n    return Number(this.get('columns'))\n  }\n\n  get lefts() {\n    return this.components.filter((c, i) => {\n      return !(i % this.columns)\n    })\n  }\n\n  get centers() {\n    return this.components.filter((c, i) => {\n      return i % this.columns && (i + 1) % this.columns\n    })\n  }\n\n  get rights() {\n    return this.components.filter((c, i) => {\n      return !((i + 1) % this.columns)\n    })\n  }\n\n  get tops() {\n    return this.components.slice(0, this.columns)\n  }\n\n  get middles() {\n    return this.components.slice(this.columns, this.columns * (this.rows - 1))\n  }\n\n  get bottoms() {\n    return this.components.slice(this.columns * (this.rows - 1))\n  }\n\n  get widths_sum() {\n    var widths = this.widths\n    return widths ? widths.filter((width, i) => i < this.columns).reduce((sum, width) => sum + width, 0) : this.columns\n  }\n\n  get heights_sum() {\n    var heights = this.heights\n    return heights ? heights.filter((height, i) => i < this.rows).reduce((sum, height) => sum + height, 0) : this.rows\n  }\n\n  get nature() {\n    return NATURE\n  }\n\n  get controls() {\n    var widths = this.widths\n    var heights = this.heights\n    var inside = this.textBounds\n\n    var width_unit = inside.width / this.widths_sum\n    var height_unit = inside.height / this.heights_sum\n\n    var x = inside.left\n    var y = inside.top\n\n    var controls = []\n\n    widths.slice(0, this.columns - 1).forEach(width => {\n      x += width * width_unit\n      controls.push({\n        x: x,\n        y: inside.top,\n        handler: columnControlHandler\n      })\n    })\n\n    heights.slice(0, this.rows - 1).forEach(height => {\n      y += height * height_unit\n      controls.push({\n        x: inside.left,\n        y: y,\n        handler: rowControlHandler\n      })\n    })\n\n    return controls\n  }\n\n  onchange(after, before) {\n    if ('rows' in after || 'columns' in after) {\n      let { rows, columns } = this\n\n      this.buildCells(\n        rows,\n        columns,\n        'rows' in before ? before.rows : rows,\n        'columns' in before ? before.columns : columns\n      )\n    }\n\n    if ('data' in after) {\n      this.setCellsData()\n    }\n  }\n\n  get eventMap() {\n    return {\n      '(self)': {\n        '(descendant)': {\n          change: this.oncellchanged\n        }\n      }\n    }\n  }\n\n  oncellchanged(after, before) {\n    if ('dataKey' in after || 'dataIndex' in after) {\n      this.setCellsData()\n    }\n  }\n}\n\n;['rows', 'columns', 'widths', 'heights', 'widths_sum', 'heights_sum', 'controls'].forEach(getter =>\n  Component.memoize(Table.prototype, getter, false)\n)\n\nComponent.register('table', Table)\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport { Component, Container, RectPath, Layout } from '@hatiolab/things-scene'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'editor-table',\n      label: '',\n      name: '',\n      property: {\n        merge: true,\n        split: true\n      }\n    },\n    {\n      type: 'string',\n      label: 'data-key',\n      name: 'dataKey',\n      property: 'dataKey'\n    },\n    {\n      type: 'number',\n      label: 'data-index',\n      name: 'dataIndex',\n      property: 'dataIndex'\n    }\n  ]\n}\n\nconst EMPTY_BORDER = {}\n\nfunction isBottomMost(idx, rows, columns) {\n  return idx >= (rows - 1) * columns\n}\n\nfunction isRightMost(idx, rows, columns) {\n  return (idx + 1) % columns == 0\n}\n\n/**\n * 1. 스타일을 상속 받아야 함. (cascade-style)\n * 2. 스타일을 동적처리할 수 있음. (로직처리)\n * 3. 데이타를 받을 수 있음.\n */\nexport default class TableCell extends RectPath(Component) {\n  // export default class TableCell extends Container {\n\n  // get layout() {\n  //   return Layout.get(this.get('layout') || 'card')\n  // }\n\n  get nature() {\n    return NATURE\n  }\n\n  set merged(merged) {\n    this.set('merged', !!merged)\n    if (merged) this.set('text', '')\n  }\n\n  get merged() {\n    return this.get('merged')\n  }\n\n  set rowspan(rowspan) {\n    this.set('rowspan', rowspan)\n  }\n\n  get rowspan() {\n    return this.get('rowspan')\n  }\n\n  set colspan(colspan) {\n    this.set('colspan', colspan)\n  }\n\n  get colspan() {\n    return this.get('colspan')\n  }\n\n  _drawBorder(context, x, y, to_x, to_y, style) {\n    if (style && style.strokeStyle && style.lineWidth && style.lineDash) {\n      context.beginPath()\n      context.moveTo(x, y)\n      context.lineTo(to_x, to_y)\n      Component.drawStroke(context, style)\n    }\n  }\n\n  _draw(context) {\n    var { left, top, width, height } = this.model\n\n    var border = this.model.border || {}\n\n    // Cell 채우기.\n    context.beginPath()\n    context.lineWidth = 0\n    context.rect(left, top, width, height)\n    this.drawFill(context)\n\n    // Border 그리기\n    var parent = this.parent\n    var idx = parent.components.indexOf(this)\n    var columns = parent.columns || 1\n    var rows = parent.rows || 1\n\n    this._drawBorder(context, left, top, left + width, top, border.top)\n    this._drawBorder(context, left, top + height, left, top, border.left)\n    if (isRightMost(idx, rows, columns))\n      this._drawBorder(context, left + width, top, left + width, top + height, border.right)\n    if (isBottomMost(idx, rows, columns))\n      this._drawBorder(context, left + width, top + height, left, top + height, border.bottom)\n  }\n}\n\nComponent.register('table-cell', TableCell)\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\nimport { Component, RectPath } from '@hatiolab/things-scene'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'editor-table',\n      label: '',\n      name: '',\n      property: {\n        merge: false,\n        split: false\n      }\n    }\n  ]\n}\n\nexport default class DataCell extends RectPath(Component) {\n  get nature() {\n    return NATURE\n  }\n\n  _drawBorder(context, x, y, to_x, to_y, style) {\n    if (style && style.strokeStyle && style.lineWidth && style.lineDash) {\n      context.beginPath()\n      context.moveTo(x, y)\n      context.lineTo(to_x, to_y)\n      Component.drawStroke(context, style)\n    }\n  }\n\n  _draw(context) {\n    var { left, top, width, height } = this.bounds\n\n    var border = this.model.border || {}\n\n    // Cell 채우기.\n    context.beginPath()\n    context.lineWidth = 0\n    context.rect(left, top, width, height)\n    this.drawFill(context)\n\n    // Border 그리기\n    var parent = this.parent\n    var idx = parent.components.indexOf(this)\n    var columns = parent.columns || 1\n\n    this._drawBorder(context, left, top, left + width, top, border.top)\n    this._drawBorder(context, left, top + height, left, top, border.left)\n    if ((idx + 1) % columns == 0) {\n      /* if this filed is right most, draw right side border. */\n      this._drawBorder(context, left + width, top, left + width, top + height, border.right)\n    }\n    this._drawBorder(context, left + width, top + height, left, top + height, border.bottom)\n  }\n}\n\nComponent.register('data-cell', DataCell)\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\n\nimport { Layout } from '@hatiolab/things-scene'\n\nvar DataListLayout = {\n  reflow: function(container) {\n    var layoutConfig = container.get('layoutConfig')\n\n    var columns = (layoutConfig && layoutConfig.columns) || container.get('columns')\n    var rows = (layoutConfig && layoutConfig.rows) || container.get('rows')\n    var widths = (layoutConfig && layoutConfig.widths) || container.get('widths')\n    var heights = (layoutConfig && layoutConfig.heights) || container.get('heights')\n    var { offset = { x: 0, y: 0 } } = container.state\n\n    var widths_sum = widths ? widths.filter((width, i) => i < columns).reduce((sum, width) => sum + width, 0) : columns\n    var heights_sum = heights ? heights.filter((height, i) => i < rows).reduce((sum, height) => sum + height, 0) : rows\n\n    var inside = container.textBounds\n    var paddingLeft = container.get('paddingLeft') || 0\n    var paddingTop = container.get('paddingTop') || 0\n\n    var width_unit = inside.width / widths_sum\n    var height_unit = inside.height / heights_sum\n\n    var x = offset.x\n    var y = offset.y\n    var components = container.components\n\n    components.forEach((component, idx) => {\n      let w = widths ? widths[idx % columns] : 1\n      let h = heights ? heights[0] : 1\n\n      let left = paddingLeft + x\n      let top = paddingTop + y\n      let width = width_unit * w\n      let height = height_unit * h\n\n      component.bounds = {\n        left,\n        top,\n        width,\n        height\n      }\n      component.set('rotation', 0)\n\n      if (idx % columns == columns - 1) {\n        x = 0\n        y += h * height_unit\n      } else {\n        x += w * width_unit\n      }\n    })\n  },\n\n  capturables: function(container) {\n    return container.components\n  },\n\n  drawables: function(container) {\n    return container.components\n  },\n\n  isStuck: function(component) {\n    return true\n  },\n\n  /*\n   * 레이아웃별로, 키보드 방향키 등을 사용해서 네비게이션 할 수 있는 기능을 제공할 수 있다.\n   * 하나의 컴포넌트만 선택되어있고, 키보드 이벤트가 발생했을 때 호출되게 된다.\n   * keyNavigate 메쏘드가 정의되어 있지 않으면, 'Tab' 키에 대한 네비게이션만 작동한다.\n   * 'Tab'키에 의한 네비게이션은 모든 레이아웃에 공통으로 적용된다.\n   */\n  keyNavigate: function(container, component, e) {\n    var layoutConfig = container.get('layoutConfig')\n\n    var columns = (layoutConfig && layoutConfig.columns) || container.get('columns')\n    var rows = (layoutConfig && layoutConfig.rows) || container.get('rows')\n\n    var { row, column } = container.getRowColumn(component)\n\n    switch (e.code) {\n      case 'ArrowUp':\n        if (row > 0) return container.getAt((row - 1) * columns + column)\n        break\n      case 'ArrowDown':\n        if (row < rows - 1) return container.getAt((row + 1) * columns + column)\n        break\n      case 'ArrowRight':\n        if (column < columns - 1) return container.getAt(row * columns + column + 1)\n        break\n      case 'ArrowLeft':\n        if (column > 0) return container.getAt(row * columns + column - 1)\n        break\n      default:\n        return component\n    }\n  },\n\n  /*\n   * 하위 컴포넌트를 영역으로 선택하는 경우에, 바운드에 join만 되어도 선택된 것으로 판단하도록 한다.\n   * joinType이 false이거나, 정의되어있지 않으면, 바운드에 포함되어야 선택된 것으로 판단한다.\n   */\n  joinType: true\n}\n\nLayout.register('data-list', DataListLayout)\n\nexport default DataListLayout\n","/*\n * Copyright © HatioLab Inc. All rights reserved.\n */\n\nimport { Component, Container, Layout, Model } from '@hatiolab/things-scene'\n\nimport './data-cell'\nimport './data-list-layout'\n\nimport {\n  CLEAR_STYLE,\n  buildNewCell,\n  buildCopiedCell,\n  setCellBorder,\n  isLeftMost,\n  isRightMost,\n  isTopMost,\n  isBottomMost,\n  above,\n  below,\n  before,\n  after,\n  array,\n  columnControlHandler,\n  rowControlHandler\n} from '../helper-functions'\n\nconst NATURE = {\n  mutable: false,\n  resizable: true,\n  rotatable: true,\n  properties: [\n    {\n      type: 'number',\n      label: 'columns',\n      name: 'columns',\n      property: 'columns'\n    }\n  ],\n  'value-property': 'data'\n}\n\nexport default class DataList extends Container {\n  render(context) {\n    super.render(context)\n\n    // 컨테이너의 범위 내에서만 그린다.\n    // container의 기본 기능으로 추가되면 좋겠다.\n    context.clip()\n  }\n\n  postrender(context) {\n    super.postrender(context)\n\n    this.renderScrollbar(context)\n  }\n\n  renderScrollbar(context) {\n    var { left, top, width, height } = this.bounds\n    var { offset = { x: 0, y: 0 }, data } = this.state\n\n    var fullHeight = ((data && data.length) || 0) * (this.heights[0] / this.heights_sum) * height\n\n    if (fullHeight <= height) {\n      return\n    }\n\n    var start = (-offset.y / fullHeight) * height\n    var end = ((-offset.y + height) / fullHeight) * height\n\n    context.strokeStyle = 'gray'\n    context.lineWidth = 10\n    context.globalAlpha = 0.3\n\n    context.moveTo(left + width - 10, top + start)\n    context.lineTo(left + width - 10, top + end)\n\n    context.stroke()\n  }\n\n  created() {\n    this.set('rows', 2)\n\n    var rows = 1\n\n    var tobeSize = rows * this.columns\n    var gap = this.size() - tobeSize\n\n    if (gap == 0) {\n      return\n    } else if (gap > 0) {\n      let removals = this._components.slice(gap)\n      this.remove(removals)\n    } else {\n      let newbies = []\n\n      for (let i = 0; i < -gap; i++) newbies.push(buildNewCell('data-cell', this.app))\n\n      this.add(newbies)\n    }\n\n    var widths = this.get('widths')\n    var heights = this.get('heights')\n\n    if (!widths || widths.length < this.columns) this.set('widths', this.widths)\n    if (!heights || heights.length < rows) this.set('heights', this.heights)\n  }\n\n  _onwheel(e) {\n    var { height } = this.bounds\n    var { offset = { x: 0, y: 0 } } = this.state\n\n    var recordHeight = (this.heights[0] / this.heights.reduce((sum, height) => sum + height)) * height\n\n    var minX = 0\n    var minY = this.data && this.data.length ? Math.min(-recordHeight * this.data.length + height, 0) : 0\n\n    /* shiftKey + wheel 은 deltaX 값을 변화시킨다. */\n    if (e.deltaY == 0 && e.deltaX == 0) return\n\n    var x = e.deltaX + offset.x\n    var y = -e.deltaY + offset.y\n\n    /* 휠을 밀면.. 화면은 위쪽으로 : scroll down */\n    /* 휠을 당기면.. 화면은 아래쪽으로 : scroll up */\n\n    this.setState({\n      offset: {\n        x: Math.max(Math.min(0, x), minX),\n        y: Math.max(Math.min(0, y), minY)\n      }\n    })\n  }\n\n  _ondragstart(e) {\n    this.__START_OFFSET = {\n      x: 0,\n      y: 0,\n      ...this.state.offset\n    }\n    this.__START_Y = e.offsetY\n  }\n\n  _ondragmove(e) {\n    if (!this.__START_OFFSET) {\n      return\n    }\n\n    var { height } = this.bounds\n\n    var recordHeight = (this.heights[0] / this.heights.reduce((sum, height) => sum + height)) * height\n    var minY = this.data && this.data.length ? -recordHeight * this.data.length + height : 0\n\n    var y = this.__START_OFFSET.y + (e.offsetY - this.__START_Y) / this.rootModel.state.scale.y\n\n    this.setState('offset', {\n      x: 0,\n      y: Math.max(Math.min(0, y), minY)\n    })\n  }\n\n  _ondragend(e) {\n    delete this.__START_OFFSET\n    delete this.__START_Y\n  }\n\n  get layout() {\n    return Layout.get('data-list')\n  }\n\n  containable(component) {\n    return component.get('type') == 'data-cell'\n  }\n\n  get focusible() {\n    /* 이 컨테이너에는 컴포넌트를 임의로 추가 및 삭제할 수 없도록 함 */\n    return false\n  }\n\n  get widths_sum() {\n    var widths = this.widths\n    return widths ? widths.filter((width, i) => i < this.columns).reduce((sum, width) => sum + width, 0) : this.columns\n  }\n\n  get heights_sum() {\n    var heights = this.heights\n    return heights ? heights.filter((height, i) => i < this.rows).reduce((sum, height) => sum + height, 0) : this.rows\n  }\n\n  get widths() {\n    var widths = this.get('widths')\n\n    if (!widths) return array(1, this.columns)\n\n    if (widths.length < this.columns) return widths.concat(array(1, this.columns - widths.length))\n    else if (widths.length > this.columns) return widths.slice(0, this.columns)\n\n    return widths\n  }\n\n  get heights() {\n    var heights = this.get('heights')\n    var rows = 2\n\n    if (!heights) {\n      return array(1, rows)\n    }\n\n    if (heights.length < rows) return heights.concat(array(1, rows - heights.length))\n    else if (heights.length > rows) return heights.slice(0, rows)\n\n    return heights\n  }\n\n  get columns() {\n    return Number(this.get('columns'))\n  }\n\n  get rows() {\n    /* 1 for first record fields, 1 for rest record fields */\n    return 2\n  }\n\n  get nature() {\n    return NATURE\n  }\n\n  get controls() {\n    var widths = this.widths\n    var heights = this.heights\n    var inside = this.textBounds\n\n    var width_unit = inside.width / this.widths_sum\n    var height_unit = inside.height / this.heights_sum\n\n    var x = inside.left\n    var y = inside.top\n\n    var controls = []\n\n    widths.slice(0, this.columns - 1).forEach(width => {\n      x += width * width_unit\n      controls.push({\n        x: x,\n        y: inside.top,\n        handler: columnControlHandler\n      })\n    })\n\n    heights.slice(0, this.rows - 1).forEach(height => {\n      y += height * height_unit\n      controls.push({\n        x: inside.left,\n        y: y,\n        handler: rowControlHandler\n      })\n    })\n\n    return controls\n  }\n\n  onchange(after, before) {\n    if ('data' in after) {\n      this.setCellsData()\n    }\n\n    if ('columns' in after) {\n      let { columns } = this\n\n      this.buildCells(columns, Number(before.columns))\n    }\n  }\n\n  get eventMap() {\n    return {\n      '(self)': {\n        '(all)': {\n          wheel: this._onwheel,\n          touchstart: this._ondragstart,\n          touchmove: this._ondragmove,\n          touchend: this._ondragend\n        }\n      }\n    }\n  }\n\n  setCellsData() {\n    if (!this.app.isViewMode) {\n      return\n    }\n\n    var data = this.data || []\n    if (!(data instanceof Array)) {\n      data = [data]\n    }\n\n    /* 기존의 레코드를 모두 삭제 (템플릿 레코드만 남긴다.) */\n    this.remove(this.components.slice(this.columns))\n\n    /* 데이타의 크기만큼 새로운 레코드를 만든다 */\n    if (data.length > 1) {\n      let newbies = []\n      let templates = this.getCellsByRow(0)\n\n      for (let i = 1; i < data.length; i++) {\n        newbies = newbies.concat(\n          templates.map(field => {\n            return Model.compile(\n              {\n                ...field.model,\n                id: '',\n                data: ''\n              },\n              this.app\n            )\n          })\n        )\n      }\n\n      this.add(newbies)\n    }\n\n    data.forEach((record, idx) => {\n      let data = {\n        _idx: idx,\n        ...record\n      }\n      let row = this.getCellsByRow(idx)\n      row.forEach(field => {\n        field.data = data\n      })\n    })\n  }\n\n  setCellsStyle(cells, style, where) {\n    var components = this.components\n    var total = components.length\n    var columns = this.get('columns')\n\n    var indices = cells.map(cell => components.indexOf(cell))\n    indices.forEach(i => {\n      var cell = components[i]\n\n      switch (where) {\n        case 'all':\n          setCellBorder(cell, style, where)\n\n          if (isLeftMost(total, columns, indices, i)) setCellBorder(components[before(columns, i)], style, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], style, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], style, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], style, 'top')\n          break\n        case 'in':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'out':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'left':\n          if (isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n            setCellBorder(components[before(columns, i)], style, 'right')\n          }\n          break\n        case 'right':\n          if (isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n            setCellBorder(components[after(columns, i)], style, 'left')\n          }\n          break\n        case 'center':\n          if (!isLeftMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'left')\n          }\n          if (!isRightMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'right')\n          }\n          break\n        case 'middle':\n          if (!isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n          }\n          if (!isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n          }\n          break\n        case 'top':\n          if (isTopMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'top')\n            setCellBorder(components[above(columns, i)], style, 'bottom')\n          }\n          break\n        case 'bottom':\n          if (isBottomMost(total, columns, indices, i)) {\n            setCellBorder(cell, style, 'bottom')\n            setCellBorder(components[below(columns, i)], style, 'top')\n          }\n          break\n        case 'clear':\n          setCellBorder(cell, CLEAR_STYLE, 'all')\n\n          if (isLeftMost(total, columns, indices, i))\n            setCellBorder(components[before(columns, i)], CLEAR_STYLE, 'right')\n          if (isRightMost(total, columns, indices, i)) setCellBorder(components[after(columns, i)], CLEAR_STYLE, 'left')\n          if (isTopMost(total, columns, indices, i)) setCellBorder(components[above(columns, i)], CLEAR_STYLE, 'bottom')\n          if (isBottomMost(total, columns, indices, i)) setCellBorder(components[below(columns, i)], CLEAR_STYLE, 'top')\n      }\n    })\n  }\n\n  buildCells(newcolumns, oldcolumns) {\n    var minrows = 1\n\n    if (newcolumns > oldcolumns) {\n      for (let r = 0; r < minrows; r++) {\n        for (let c = oldcolumns; c < newcolumns; c++) {\n          this.insertComponentAt(buildNewCell('data-cell', this.app), r * newcolumns + c)\n        }\n      }\n    } else if (newcolumns < oldcolumns) {\n      let removals = []\n\n      for (let r = 0; r < minrows; r++) {\n        for (let c = newcolumns; c < oldcolumns; c++) {\n          removals.push(this.components[r * oldcolumns + c])\n        }\n      }\n\n      this.remove(removals)\n    }\n\n    this.set({\n      widths: this.widths,\n      heights: this.heights\n    })\n\n    this.setCellsData()\n  }\n\n  getRowColumn(cell) {\n    var idx = this.components.indexOf(cell)\n\n    return {\n      column: idx % this.columns,\n      row: Math.floor(idx / this.columns)\n    }\n  }\n\n  getCellsByRow(row) {\n    return this.components.slice(row * this.columns, (row + 1) * this.columns)\n  }\n\n  getCellsByColumn(column) {\n    var cells = []\n    for (let i = 0; i < this.rows; i++) cells.push(this.components[this.columns * i + column])\n\n    return cells\n  }\n\n  mergeCells(cells) {}\n\n  splitCells(cells) {}\n\n  deleteRows(cells) {}\n\n  deleteColumns(cells) {\n    // 만약 선택한 셀이 병합된 셀이라면 삭제하지 않는다.\n    if (cells[0].merged == true) return false\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n\n    columns.forEach(column => {\n      var widths = this.widths.slice()\n      this.remove(this.getCellsByColumn(column))\n\n      widths.splice(column, 1)\n      this.model.columns -= 1 // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n      this.set('widths', widths)\n    })\n  }\n\n  insertCellsAbove(cells) {}\n\n  insertCellsBelow(cells) {}\n\n  insertCellsLeft(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[0]\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      for (let i = 0; i < this.rows; i++)\n        newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n      newbieColumnWidths.push(this.widths[column])\n\n      let increasedColumns = this.columns\n      let index = this.rows\n      newbieCells.reverse().forEach(cell => {\n        if (index == 0) {\n          index = this.rows\n          increasedColumns++\n        }\n\n        index--\n        this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n      })\n\n      let widths = this.widths.slice()\n      this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n      widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n      this.set('widths', widths)\n    })\n  }\n\n  insertCellsRight(cells) {\n    // 먼저 cells 위치의 열을 구한다.\n    let columns = []\n    cells.forEach(cell => {\n      let column = this.getRowColumn(cell).column\n      if (-1 == columns.indexOf(column)) columns.push(column)\n    })\n    columns.sort((a, b) => {\n      return a - b\n    })\n    columns.reverse()\n    // 열 2개 이상은 추가 안함. 임시로 막아놓음\n    if (columns.length >= 2) return false\n    let insertionColumnPosition = columns[columns.length - 1] + 1\n    let newbieColumnWidths = []\n    let newbieCells = []\n    columns.forEach(column => {\n      for (let i = 0; i < this.rows; i++)\n        newbieCells.push(buildCopiedCell(this.components[column + this.columns * i].model, this.app))\n      newbieColumnWidths.push(this.widths[column])\n\n      let increasedColumns = this.columns\n      let index = this.rows\n      newbieCells.reverse().forEach(cell => {\n        if (index == 0) {\n          index = this.rows\n          increasedColumns++\n        }\n\n        index--\n        this.insertComponentAt(cell, insertionColumnPosition + index * increasedColumns)\n      })\n\n      let widths = this.widths.slice()\n      this.model.columns += columns.length // 고의적으로, change 이벤트가 발생하지 않도록 set(..)을 사용하지 않음.\n\n      widths.splice(insertionColumnPosition, 0, ...newbieColumnWidths)\n\n      this.set('widths', widths)\n    })\n  }\n\n  distributeHorizontal(cells) {\n    var columns = []\n\n    cells.forEach(cell => {\n      let rowcolumn = this.getRowColumn(cell)\n\n      if (-1 == columns.indexOf(rowcolumn.column)) columns.push(rowcolumn.column)\n    })\n\n    var sum = columns.reduce((sum, column) => {\n      return sum + this.widths[column]\n    }, 0)\n\n    var newval = Math.round((sum / columns.length) * 100) / 100\n    var widths = this.widths.slice()\n    columns.forEach(column => {\n      widths[column] = newval\n    })\n\n    this.set('widths', widths)\n  }\n\n  distributeVertical(cells) {}\n}\n\nComponent.register('data-list', DataList)\n"],"names":["SIDES","all","out","left","right","top","bottom","leftright","topbottom","CLEAR_STYLE","strokeStyle","lineDash","lineWidth","DEFAULT_STYLE","buildNewCell","type","app","Model","compile","width","height","textWrap","border","buildBorderStyle","buildCopiedCell","copy","obj","JSON","parse","stringify","text","style","where","reduce","side","setCellBorder","cell","set","Object","assign","get","isLeftMost","total","columns","indices","i","indexOf","isRightMost","isTopMost","isBottomMost","above","below","before","after","array","value","size","arr","push","columnControlHandler","ondragmove","point","index","component","textBounds","widths_sum","widths","slice","origin_offset","sum","diff_unit","transcoordP2S","x","y","min_width_unit","Math","min","round","rowControlHandler","heights_sum","heights","min_height_unit","NATURE","mutable","resizable","rotatable","properties","label","name","property","options","Table","Container","tobeSize","this","rows","gap","removals","_components","remove","newbies","add","length","newrows","newcolumns","oldrows","oldcolumns","mergedCells","forEach","merged","rowspan","colspan","superCells","superCellIndexes","col","row","_this","components","floor","spColStart","spColEnd","spRowStart","spRowEnd","minrows","r","c","insertComponentAt","cells","_cells","_this2","getRowColumn","column","j","map","data","toObjectArrayValue","state","spreadTo","dataKey","model","dataIndex","idx","mergeableRows","_this3","mergeableColumns","numberOfRows","numberOfColumns","numberOfCells","sort","a","b","firstCell","root","selected","firstCellIndex","lastCell","startIndex","_this4","reverse","findMergedCellByX","getCellsByRow","superCellRow","splice","_this5","findMergedCellByY","getCellsByColumn","superCellColumn","_this6","insertionRowPosition","newbieRowHeights","newbieCells","clearCache","superCellObj","_this7","_this8","insertionColumnPosition","newbieColumnWidths","increasedColumns","rowIndex","_this9","rowcolumn","_this10","newval","_this11","hasOwnProperty","indexKeyMap","key","object","thisObject","k","v","buildCells","setCellsData","concat","Layout","Number","filter","_this12","_this13","_this14","_this15","_this16","inside","width_unit","height_unit","controls","handler","change","oncellchanged","getter","Component","memoize","prototype","register","merge","split","TableCell","RectPath","context","to_x","to_y","beginPath","moveTo","lineTo","drawStroke","rect","drawFill","parent","_drawBorder","DataCell","bounds","reflow","container","layoutConfig","offset","paddingLeft","paddingTop","w","h","capturables","drawables","isStuck","keyNavigate","e","code","getAt","joinType","DataList","clip","renderScrollbar","fullHeight","start","end","globalAlpha","stroke","recordHeight","minY","deltaY","deltaX","setState","max","__START_OFFSET","__START_Y","offsetY","rootModel","scale","isViewMode","Array","templates","field","id","record","_idx","wheel","_onwheel","touchstart","_ondragstart","touchmove","_ondragmove","touchend","_ondragend"],"mappings":"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"}